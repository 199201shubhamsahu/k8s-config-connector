// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Config Connector and manual
//     changes will be clobbered when the file is regenerated.
//
// ----------------------------------------------------------------------------

package v1beta1

import (
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/apis/k8s/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type AccessKeyId struct {
	/* Value of the field. Cannot be used if 'valueFrom' is specified. */
	Value string `json:"value,omitempty"`
	/* Source for the field's value. Cannot be used if 'value' is specified. */
	ValueFrom ValueFrom `json:"valueFrom,omitempty"`
}

type AwsAccessKey struct {
	/* AWS Key ID. */
	AccessKeyId AccessKeyId `json:"accessKeyId,omitempty"`
	/* AWS Secret Access Key. */
	SecretAccessKey SecretAccessKey `json:"secretAccessKey,omitempty"`
}

type AwsS3DataSource struct {
	/* AWS credentials block. */
	AwsAccessKey AwsAccessKey `json:"awsAccessKey,omitempty"`
	/* S3 Bucket name. */
	BucketName string `json:"bucketName,omitempty"`
}

type GcsDataSink struct {
	/*  */
	BucketRef v1alpha1.ResourceRef `json:"bucketRef,omitempty"`
}

type GcsDataSource struct {
	/*  */
	BucketRef v1alpha1.ResourceRef `json:"bucketRef,omitempty"`
}

type HttpDataSource struct {
	/* The URL that points to the file that stores the object list entries. This file must allow public access. Currently, only URLs with HTTP and HTTPS schemes are supported. */
	ListUrl string `json:"listUrl,omitempty"`
}

type ObjectConditions struct {
	/* exclude_prefixes must follow the requirements described for include_prefixes. */
	ExcludePrefixes []string `json:"excludePrefixes,omitempty"`
	/* If include_refixes is specified, objects that satisfy the object conditions must have names that start with one of the include_prefixes and that do not start with any of the exclude_prefixes. If include_prefixes is not specified, all objects except those that have names starting with one of the exclude_prefixes must satisfy the object conditions. */
	IncludePrefixes []string `json:"includePrefixes,omitempty"`
	/* A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". */
	MaxTimeElapsedSinceLastModification string `json:"maxTimeElapsedSinceLastModification,omitempty"`
	/* A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". */
	MinTimeElapsedSinceLastModification string `json:"minTimeElapsedSinceLastModification,omitempty"`
}

type Schedule struct {
	/* Immutable. The last day the recurring transfer will be run. If schedule_end_date is the same as schedule_start_date, the transfer will be executed only once. */
	ScheduleEndDate ScheduleEndDate `json:"scheduleEndDate,omitempty"`
	/* Immutable. The first day the recurring transfer is scheduled to run. If schedule_start_date is in the past, the transfer will run for the first time on the following day. */
	ScheduleStartDate ScheduleStartDate `json:"scheduleStartDate,omitempty"`
	/* Immutable. The time in UTC at which the transfer will be scheduled to start in a day. Transfers may start later than this time. If not specified, recurring and one-time transfers that are scheduled to run today will run immediately; recurring transfers that are scheduled to run on a future date will start at approximately midnight UTC on that date. Note that when configuring a transfer with the Cloud Platform Console, the transfer's start time in a day is specified in your local timezone. */
	StartTimeOfDay StartTimeOfDay `json:"startTimeOfDay,omitempty"`
}

type ScheduleEndDate struct {
	/* Immutable. Day of month. Must be from 1 to 31 and valid for the year and month. */
	Day int `json:"day,omitempty"`
	/* Immutable. Month of year. Must be from 1 to 12. */
	Month int `json:"month,omitempty"`
	/* Immutable. Year of date. Must be from 1 to 9999. */
	Year int `json:"year,omitempty"`
}

type ScheduleStartDate struct {
	/* Immutable. Day of month. Must be from 1 to 31 and valid for the year and month. */
	Day int `json:"day,omitempty"`
	/* Immutable. Month of year. Must be from 1 to 12. */
	Month int `json:"month,omitempty"`
	/* Immutable. Year of date. Must be from 1 to 9999. */
	Year int `json:"year,omitempty"`
}

type SecretAccessKey struct {
	/* Value of the field. Cannot be used if 'valueFrom' is specified. */
	Value string `json:"value,omitempty"`
	/* Source for the field's value. Cannot be used if 'value' is specified. */
	ValueFrom ValueFrom `json:"valueFrom,omitempty"`
}

type StartTimeOfDay struct {
	/* Immutable. Hours of day in 24 hour format. Should be from 0 to 23. */
	Hours int `json:"hours,omitempty"`
	/* Immutable. Minutes of hour of day. Must be from 0 to 59. */
	Minutes int `json:"minutes,omitempty"`
	/* Immutable. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999. */
	Nanos int `json:"nanos,omitempty"`
	/* Immutable. Seconds of minutes of the time. Must normally be from 0 to 59. */
	Seconds int `json:"seconds,omitempty"`
}

type TransferOptions struct {
	/* Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and delete_objects_unique_in_sink are mutually exclusive. */
	DeleteObjectsFromSourceAfterTransfer bool `json:"deleteObjectsFromSourceAfterTransfer,omitempty"`
	/* Whether objects that exist only in the sink should be deleted. Note that this option and delete_objects_from_source_after_transfer are mutually exclusive. */
	DeleteObjectsUniqueInSink bool `json:"deleteObjectsUniqueInSink,omitempty"`
	/* Whether overwriting objects that already exist in the sink is allowed. */
	OverwriteObjectsAlreadyExistingInSink bool `json:"overwriteObjectsAlreadyExistingInSink,omitempty"`
}

type TransferSpec struct {
	/* An AWS S3 data source. */
	AwsS3DataSource AwsS3DataSource `json:"awsS3DataSource,omitempty"`
	/* A Google Cloud Storage data sink. */
	GcsDataSink GcsDataSink `json:"gcsDataSink,omitempty"`
	/* A Google Cloud Storage data source. */
	GcsDataSource GcsDataSource `json:"gcsDataSource,omitempty"`
	/* An HTTP URL data source. */
	HttpDataSource HttpDataSource `json:"httpDataSource,omitempty"`
	/* Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' last_modification_time do not exclude objects in a data sink. */
	ObjectConditions ObjectConditions `json:"objectConditions,omitempty"`
	/* Characteristics of how to treat files from datasource and sink during job. If the option delete_objects_unique_in_sink is true, object conditions based on objects' last_modification_time are ignored and do not exclude objects in a data source or a data sink. */
	TransferOptions TransferOptions `json:"transferOptions,omitempty"`
}

type ValueFrom struct {
	/* Reference to a value with the given key in the given Secret in the resource's namespace. */
	SecretKeyRef v1alpha1.ResourceRef `json:"secretKeyRef,omitempty"`
}

type StorageTransferJobSpec struct {
	/* Unique description to identify the Transfer Job. */
	Description string `json:"description,omitempty"`
	/* Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource. */
	ResourceID string `json:"resourceID,omitempty"`
	/* Schedule specification defining when the Transfer Job should be scheduled to start, end and what time to run. */
	Schedule Schedule `json:"schedule,omitempty"`
	/* Status of the job. Default: ENABLED. NOTE: The effect of the new job status takes place during a subsequent job run. For example, if you change the job status from ENABLED to DISABLED, and an operation spawned by the transfer is running, the status change would not affect the current operation. */
	Status string `json:"status,omitempty"`
	/* Transfer specification. */
	TransferSpec TransferSpec `json:"transferSpec,omitempty"`
}

type StorageTransferJobStatus struct {
	/* Conditions represents the latest available observations of the
	   StorageTransferJob's current state. */
	Conditions []v1alpha1.Condition `json:"conditions,omitempty"`
	/* When the Transfer Job was created. */
	CreationTime string `json:"creationTime,omitempty"`
	/* When the Transfer Job was deleted. */
	DeletionTime string `json:"deletionTime,omitempty"`
	/* When the Transfer Job was last modified. */
	LastModificationTime string `json:"lastModificationTime,omitempty"`
	/* The name of the Transfer Job. */
	Name string `json:"name,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// StorageTransferJob is the Schema for the storagetransfer API
// +k8s:openapi-gen=true
type StorageTransferJob struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   StorageTransferJobSpec   `json:"spec,omitempty"`
	Status StorageTransferJobStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// StorageTransferJobList contains a list of StorageTransferJob
type StorageTransferJobList struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Items             []StorageTransferJob `json:"items"`
}

func init() {
	SchemeBuilder.Register(&StorageTransferJob{}, &StorageTransferJobList{})
}
