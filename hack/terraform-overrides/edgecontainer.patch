diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/.teamcity/components/generated/services.kt b/third_party/github.com/hashicorp/terraform-provider-google-beta/.teamcity/components/generated/services.kt
index d16be1899..7dc27d79c 100644
--- a/third_party/github.com/hashicorp/terraform-provider-google-beta/.teamcity/components/generated/services.kt
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/.teamcity/components/generated/services.kt
@@ -320,6 +320,11 @@ var services = mapOf(
         "name" to "edgenetwork",
         "displayName" to "Edgenetwork",
         "path" to "./google-beta/services/edgenetwork"
+    )
+    "edgecontainer" to mapOf(
+        "name" to "edgecontainer",
+        "displayName" to "Edgecontainer",
+        "path" to "./google-beta/services/edgecontainer"
     ),
     "essentialcontacts" to mapOf(
         "name" to "essentialcontacts",
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwmodels/provider_model.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwmodels/provider_model.go
index 45783b9d1..08043e0c0 100644
--- a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwmodels/provider_model.go
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwmodels/provider_model.go
@@ -79,6 +79,7 @@ type ProviderModel struct {
 	DocumentAICustomEndpoint               types.String `tfsdk:"document_ai_custom_endpoint"`
 	DocumentAIWarehouseCustomEndpoint      types.String `tfsdk:"document_ai_warehouse_custom_endpoint"`
 	EdgenetworkCustomEndpoint              types.String `tfsdk:"edgenetwork_custom_endpoint"`
+	EdgecontainerCustomEndpoint            types.String `tfsdk:"edgecontainer_custom_endpoint"`
 	EssentialContactsCustomEndpoint        types.String `tfsdk:"essential_contacts_custom_endpoint"`
 	FilestoreCustomEndpoint                types.String `tfsdk:"filestore_custom_endpoint"`
 	FirebaseCustomEndpoint                 types.String `tfsdk:"firebase_custom_endpoint"`
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwprovider/framework_provider.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwprovider/framework_provider.go
index 51c19e5ff..99104b780 100644
--- a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwprovider/framework_provider.go
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwprovider/framework_provider.go
@@ -444,6 +444,12 @@ func (p *FrameworkProvider) Schema(_ context.Context, _ provider.SchemaRequest,
 					transport_tpg.CustomEndpointValidator(),
 				},
 			},
+			"edgecontainer_custom_endpoint": &schema.StringAttribute{
+				Optional: true,
+				Validators: []validator.String{
+					transport_tpg.CustomEndpointValidator(),
+				},
+			},
 			"essential_contacts_custom_endpoint": &schema.StringAttribute{
 				Optional: true,
 				Validators: []validator.String{
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwtransport/framework_config.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwtransport/framework_config.go
index b854e3805..26e6aaf12 100644
--- a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwtransport/framework_config.go
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/fwtransport/framework_config.go
@@ -104,6 +104,7 @@ type FrameworkProviderConfig struct {
 	DocumentAIBasePath               string
 	DocumentAIWarehouseBasePath      string
 	EdgenetworkBasePath              string
+	EdgecontainerBasePath            string
 	EssentialContactsBasePath        string
 	FilestoreBasePath                string
 	FirebaseBasePath                 string
@@ -266,6 +267,7 @@ func (p *FrameworkProviderConfig) LoadAndValidateFramework(ctx context.Context,
 	p.DocumentAIBasePath = data.DocumentAICustomEndpoint.ValueString()
 	p.DocumentAIWarehouseBasePath = data.DocumentAIWarehouseCustomEndpoint.ValueString()
 	p.EdgenetworkBasePath = data.EdgenetworkCustomEndpoint.ValueString()
+	p.EdgecontainerBasePath = data.EdgecontainerCustomEndpoint.ValueString()
 	p.EssentialContactsBasePath = data.EssentialContactsCustomEndpoint.ValueString()
 	p.FilestoreBasePath = data.FilestoreCustomEndpoint.ValueString()
 	p.FirebaseBasePath = data.FirebaseCustomEndpoint.ValueString()
@@ -962,6 +964,14 @@ func (p *FrameworkProviderConfig) HandleDefaults(ctx context.Context, data *fwmo
 			data.EdgenetworkCustomEndpoint = types.StringValue(customEndpoint.(string))
 		}
 	}
+	if data.EdgecontainerCustomEndpoint.IsNull() {
+		customEndpoint := transport_tpg.MultiEnvDefault([]string{
+			"GOOGLE_EDGECONTAINER_CUSTOM_ENDPOINT",
+		}, transport_tpg.DefaultBasePaths[transport_tpg.EdgecontainerBasePathKey])
+		if customEndpoint != nil {
+			data.EdgecontainerCustomEndpoint = types.StringValue(customEndpoint.(string))
+		}
+	}
 	if data.EssentialContactsCustomEndpoint.IsNull() {
 		customEndpoint := transport_tpg.MultiEnvDefault([]string{
 			"GOOGLE_ESSENTIAL_CONTACTS_CUSTOM_ENDPOINT",
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/provider/provider.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/provider/provider.go
index 3acc6042d..2c1aa87ee 100644
--- a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/provider/provider.go
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/provider/provider.go
@@ -67,6 +67,7 @@ import (
 	"github.com/hashicorp/terraform-provider-google-beta/google-beta/services/documentai"
 	"github.com/hashicorp/terraform-provider-google-beta/google-beta/services/documentaiwarehouse"
 	"github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgenetwork"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer"
 	"github.com/hashicorp/terraform-provider-google-beta/google-beta/services/essentialcontacts"
 	"github.com/hashicorp/terraform-provider-google-beta/google-beta/services/filestore"
 	"github.com/hashicorp/terraform-provider-google-beta/google-beta/services/firebase"
@@ -517,6 +518,11 @@ func Provider() *schema.Provider {
 				Optional:     true,
 				ValidateFunc: transport_tpg.ValidateCustomEndpoint,
 			},
+			"edgecontainer_custom_endpoint": {
+				Type:         schema.TypeString,
+				Optional:     true,
+				ValidateFunc: transport_tpg.ValidateCustomEndpoint,
+			},
 			"essential_contacts_custom_endpoint": {
 				Type:         schema.TypeString,
 				Optional:     true,
@@ -1491,6 +1497,9 @@ func ResourceMapWithErrors() (map[string]*schema.Resource, error) {
 			"google_document_ai_warehouse_location":                          documentaiwarehouse.ResourceDocumentAIWarehouseLocation(),
 			"google_edgenetwork_network":                                     edgenetwork.ResourceEdgenetworkNetwork(),
 			"google_edgenetwork_subnet":                                      edgenetwork.ResourceEdgenetworkSubnet(),
+			"google_edgecontainer_cluster":                                   edgecontainer.ResourceEdgecontainerCluster(),
+			"google_edgecontainer_node_pool":                                 edgecontainer.ResourceEdgecontainerNodePool(),
+			"google_edgecontainer_vpn_connection":                            edgecontainer.ResourceEdgecontainerVpnConnection(),
 			"google_essential_contacts_contact":                              essentialcontacts.ResourceEssentialContactsContact(),
 			"google_filestore_backup":                                        filestore.ResourceFilestoreBackup(),
 			"google_filestore_instance":                                      filestore.ResourceFilestoreInstance(),
@@ -2066,6 +2075,7 @@ func ProviderConfigure(ctx context.Context, d *schema.ResourceData, p *schema.Pr
 	config.DocumentAIBasePath = d.Get("document_ai_custom_endpoint").(string)
 	config.DocumentAIWarehouseBasePath = d.Get("document_ai_warehouse_custom_endpoint").(string)
 	config.EdgenetworkBasePath = d.Get("edgenetwork_custom_endpoint").(string)
+	config.EdgecontainerBasePath = d.Get("edgecontainer_custom_endpoint").(string)
 	config.EssentialContactsBasePath = d.Get("essential_contacts_custom_endpoint").(string)
 	config.FilestoreBasePath = d.Get("filestore_custom_endpoint").(string)
 	config.FirebaseBasePath = d.Get("firebase_custom_endpoint").(string)
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/edgecontainer_operation.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/edgecontainer_operation.go
new file mode 100644
index 000000000..f0aceb3a3
--- /dev/null
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/edgecontainer_operation.go
@@ -0,0 +1,92 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+// ----------------------------------------------------------------------------
+//
+//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
+//
+// ----------------------------------------------------------------------------
+//
+//     This file is automatically generated by Magic Modules and manual
+//     changes will be clobbered when the file is regenerated.
+//
+//     Please read more about how to change this file in
+//     .github/CONTRIBUTING.md.
+//
+// ----------------------------------------------------------------------------
+
+package edgecontainer
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+	"time"
+
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
+	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
+)
+
+type EdgecontainerOperationWaiter struct {
+	Config    *transport_tpg.Config
+	UserAgent string
+	Project   string
+	tpgresource.CommonOperationWaiter
+}
+
+func (w *EdgecontainerOperationWaiter) QueryOp() (interface{}, error) {
+	if w == nil {
+		return nil, fmt.Errorf("Cannot query operation, it's unset or nil.")
+	}
+	// Returns the proper get.
+	url := fmt.Sprintf("%s%s", w.Config.EdgecontainerBasePath, w.CommonOperationWaiter.Op.Name)
+
+	return transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    w.Config,
+		Method:    "GET",
+		Project:   w.Project,
+		RawURL:    url,
+		UserAgent: w.UserAgent,
+	})
+}
+
+func createEdgecontainerWaiter(config *transport_tpg.Config, op map[string]interface{}, project, activity, userAgent string) (*EdgecontainerOperationWaiter, error) {
+	w := &EdgecontainerOperationWaiter{
+		Config:    config,
+		UserAgent: userAgent,
+		Project:   project,
+	}
+	if err := w.CommonOperationWaiter.SetOp(op); err != nil {
+		return nil, err
+	}
+	return w, nil
+}
+
+// nolint: deadcode,unused
+func EdgecontainerOperationWaitTimeWithResponse(config *transport_tpg.Config, op map[string]interface{}, response *map[string]interface{}, project, activity, userAgent string, timeout time.Duration) error {
+	w, err := createEdgecontainerWaiter(config, op, project, activity, userAgent)
+	if err != nil {
+		return err
+	}
+	if err := tpgresource.OperationWait(w, activity, timeout, config.PollInterval); err != nil {
+		return err
+	}
+	rawResponse := []byte(w.CommonOperationWaiter.Op.Response)
+	if len(rawResponse) == 0 {
+		return errors.New("`resource` not set in operation response")
+	}
+	return json.Unmarshal(rawResponse, response)
+}
+
+func EdgecontainerOperationWaitTime(config *transport_tpg.Config, op map[string]interface{}, project, activity, userAgent string, timeout time.Duration) error {
+	if val, ok := op["name"]; !ok || val == "" {
+		// This was a synchronous call - there is no operation to wait for.
+		return nil
+	}
+	w, err := createEdgecontainerWaiter(config, op, project, activity, userAgent)
+	if err != nil {
+		// If w is nil, the op was synchronous.
+		return err
+	}
+	return tpgresource.OperationWait(w, activity, timeout, config.PollInterval)
+}
\ No newline at end of file
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_cluster.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_cluster.go
new file mode 100644
index 000000000..813640ef0
--- /dev/null
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_cluster.go
@@ -0,0 +1,2102 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+// ----------------------------------------------------------------------------
+//
+//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
+//
+// ----------------------------------------------------------------------------
+//
+//     This file is automatically generated by Magic Modules and manual
+//     changes will be clobbered when the file is regenerated.
+//
+//     Please read more about how to change this file in
+//     .github/CONTRIBUTING.md.
+//
+// ----------------------------------------------------------------------------
+
+package edgecontainer
+
+import (
+	"fmt"
+	"log"
+	"reflect"
+	"strings"
+	"time"
+
+		"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
+
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
+	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"
+)
+
+func ResourceEdgecontainerCluster() *schema.Resource {
+	return &schema.Resource{
+		Create: resourceEdgecontainerClusterCreate,
+		Read:   resourceEdgecontainerClusterRead,
+		Update: resourceEdgecontainerClusterUpdate,
+		Delete: resourceEdgecontainerClusterDelete,
+
+		Importer: &schema.ResourceImporter{
+			State: resourceEdgecontainerClusterImport,
+		},
+
+		Timeouts: &schema.ResourceTimeout{
+			Create: schema.DefaultTimeout(60 * time.Minute),
+			Update: schema.DefaultTimeout(60 * time.Minute),
+			Delete: schema.DefaultTimeout(60 * time.Minute),
+		},
+
+		Schema: map[string]*schema.Schema{
+			"authorization": {
+				Type:        schema.TypeList,
+				Required:    true,
+				ForceNew:    true,
+				Description: `RBAC policy that will be applied and managed by GEC.`,
+				MaxItems:    1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"admin_users": {
+							Type:     schema.TypeList,
+							Required: true,
+							Description: `User that will be granted the cluster-admin role on the cluster, providing
+full access to the cluster. Currently, this is a singular field, but will
+be expanded to allow multiple admins in the future.`,
+							MaxItems: 1,
+							Elem: &schema.Resource{
+								Schema: map[string]*schema.Schema{
+									"username": {
+										Type:        schema.TypeString,
+										Required:    true,
+										Description: `An active Google username.`,
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			"fleet": {
+				Type:     schema.TypeList,
+				Required: true,
+				ForceNew: true,
+				Description: `Fleet related configuration.
+Fleets are a Google Cloud concept for logically organizing clusters,
+letting you use and manage multi-cluster capabilities and apply
+consistent policies across your systems.`,
+				MaxItems: 1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"project": {
+							Type:     schema.TypeString,
+							Required: true,
+							ForceNew: true,
+							Description: `The name of the Fleet host project where this cluster will be registered.
+Project names are formatted as
+'projects/<project-number>'.`,
+						},
+						"membership": {
+							Type:     schema.TypeString,
+							Computed: true,
+							Description: `The name of the managed Hub Membership resource associated to this cluster.
+Membership names are formatted as
+'projects/<project-number>/locations/global/membership/<cluster-id>'.`,
+						},
+					},
+				},
+			},
+			"location": {
+				Type:        schema.TypeString,
+				Required:    true,
+				ForceNew:    true,
+				Description: `The location of the resource.`,
+			},
+			"name": {
+				Type:        schema.TypeString,
+				Required:    true,
+				ForceNew:    true,
+				Description: `The GDCE cluster name.`,
+			},
+			"networking": {
+				Type:     schema.TypeList,
+				Required: true,
+				Description: `Fleet related configuration.
+Fleets are a Google Cloud concept for logically organizing clusters,
+letting you use and manage multi-cluster capabilities and apply
+consistent policies across your systems.`,
+				MaxItems: 1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"cluster_ipv4_cidr_blocks": {
+							Type:     schema.TypeList,
+							Required: true,
+							ForceNew: true,
+							Description: `All pods in the cluster are assigned an RFC1918 IPv4 address from these
+blocks. Only a single block is supported. This field cannot be changed
+after creation.`,
+							Elem: &schema.Schema{
+								Type: schema.TypeString,
+							},
+						},
+						"services_ipv4_cidr_blocks": {
+							Type:     schema.TypeList,
+							Required: true,
+							ForceNew: true,
+							Description: `All services in the cluster are assigned an RFC1918 IPv4 address from these
+blocks. Only a single block is supported. This field cannot be changed
+after creation.`,
+							Elem: &schema.Schema{
+								Type: schema.TypeString,
+							},
+						},
+						"cluster_ipv6_cidr_blocks": {
+							Type:     schema.TypeList,
+							Optional: true,
+							ForceNew: true,
+							Description: `If specified, dual stack mode is enabled and all pods in the cluster are
+assigned an IPv6 address from these blocks alongside from an IPv4
+address. Only a single block is supported. This field cannot be changed
+after creation.`,
+							Elem: &schema.Schema{
+								Type: schema.TypeString,
+							},
+						},
+						"services_ipv6_cidr_blocks": {
+							Type:     schema.TypeList,
+							Optional: true,
+							ForceNew: true,
+							Description: `If specified, dual stack mode is enabled and all services in the cluster are
+assigned an IPv6 address from these blocks alongside from an IPv4
+address. Only a single block is supported. This field cannot be changed
+after creation.`,
+							Elem: &schema.Schema{
+								Type: schema.TypeString,
+							},
+						},
+						"network_type": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `IP addressing type of this cluster i.e. SINGLESTACK_V4 vs DUALSTACK_V4_V6.`,
+						},
+					},
+				},
+			},
+			"control_plane": {
+				Type:        schema.TypeList,
+				Optional:    true,
+				Description: `The configuration of the cluster control plane.`,
+				MaxItems:    1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"local": {
+							Type:        schema.TypeList,
+							Computed:    true,
+							Optional:    true,
+							ForceNew:    true,
+							Description: `Local control plane configuration.`,
+							MaxItems:    1,
+							Elem: &schema.Resource{
+								Schema: map[string]*schema.Schema{
+									"machine_filter": {
+										Type:     schema.TypeString,
+										Optional: true,
+										Description: `Only machines matching this filter will be allowed to host control
+plane nodes. The filtering language accepts strings like "name=<name>",
+and is documented here: [AIP-160](https://google.aip.dev/160).`,
+									},
+									"node_count": {
+										Type:     schema.TypeInt,
+										Computed: true,
+										Optional: true,
+										Description: `The number of nodes to serve as replicas of the Control Plane.
+Only 1 and 3 are supported.`,
+									},
+									"node_location": {
+										Type:     schema.TypeString,
+										Computed: true,
+										Optional: true,
+										ForceNew: true,
+										Description: `Name of the Google Distributed Cloud Edge zones where this node pool
+will be created. For example: 'us-central1-edge-customer-a'.`,
+									},
+									"shared_deployment_policy": {
+										Type:         schema.TypeString,
+										Computed:     true,
+										Optional:     true,
+										ValidateFunc: verify.ValidateEnum([]string{"SHARED_DEPLOYMENT_POLICY_UNSPECIFIED", "ALLOWED", "DISALLOWED", ""}),
+										Description:  `Policy configuration about how user applications are deployed. Possible values: ["SHARED_DEPLOYMENT_POLICY_UNSPECIFIED", "ALLOWED", "DISALLOWED"]`,
+									},
+								},
+							},
+							ExactlyOneOf: []string{"control_plane.0.remote", "control_plane.0.local"},
+						},
+						"remote": {
+							Type:        schema.TypeList,
+							Computed:    true,
+							Optional:    true,
+							ForceNew:    true,
+							Description: `Remote control plane configuration.`,
+							MaxItems:    1,
+							Elem: &schema.Resource{
+								Schema: map[string]*schema.Schema{
+									"node_location": {
+										Type:     schema.TypeString,
+										Computed: true,
+										Optional: true,
+										ForceNew: true,
+										Description: `Name of the Google Distributed Cloud Edge zones where this node pool
+will be created. For example: 'us-central1-edge-customer-a'.`,
+									},
+								},
+							},
+							ExactlyOneOf: []string{"control_plane.0.remote", "control_plane.0.local"},
+						},
+					},
+				},
+			},
+			"control_plane_encryption": {
+				Type:     schema.TypeList,
+				Computed: true,
+				Optional: true,
+				Description: `Remote control plane disk encryption options. This field is only used when
+enabling CMEK support.`,
+				MaxItems: 1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"kms_key": {
+							Type:     schema.TypeString,
+							Computed: true,
+							Optional: true,
+							ForceNew: true,
+							Description: `The Cloud KMS CryptoKey e.g.
+projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
+to use for protecting control plane disks. If not specified, a
+Google-managed key will be used instead.`,
+						},
+						"kms_key_active_version": {
+							Type:     schema.TypeString,
+							Computed: true,
+							Description: `The Cloud KMS CryptoKeyVersion currently in use for protecting control
+plane disks. Only applicable if kms_key is set.`,
+						},
+						"kms_key_state": {
+							Type:     schema.TypeString,
+							Computed: true,
+							Description: `Availability of the Cloud KMS CryptoKey. If not 'KEY_AVAILABLE', then
+nodes may go offline as they cannot access their local data. This can be
+caused by a lack of permissions to use the key, or if the key is disabled
+or deleted.`,
+						},
+						"kms_status": {
+							Type:     schema.TypeList,
+							Computed: true,
+							Description: `Error status returned by Cloud KMS when using this key. This field may be
+populated only if 'kms_key_state' is not 'KMS_KEY_STATE_KEY_AVAILABLE'.
+If populated, this field contains the error status reported by Cloud KMS.`,
+							Elem: &schema.Resource{
+								Schema: map[string]*schema.Schema{
+									"code": {
+										Type:        schema.TypeInt,
+										Computed:    true,
+										Description: `The status code, which should be an enum value of google.rpc.Code.`,
+									},
+									"message": {
+										Type:        schema.TypeString,
+										Computed:    true,
+										Description: `A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.`,
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			"default_max_pods_per_node": {
+				Type:     schema.TypeInt,
+				Computed: true,
+				Optional: true,
+				Description: `The default maximum number of pods per node used if a maximum value is not
+specified explicitly for a node pool in this cluster. If unspecified, the
+Kubernetes default value will be used.`,
+			},
+			"external_load_balancer_ipv4_address_pools": {
+				Type:        schema.TypeList,
+				Computed:    true,
+				Optional:    true,
+				Description: `Address pools for cluster data plane external load balancing.`,
+				Elem: &schema.Schema{
+					Type: schema.TypeString,
+				},
+			},
+			"labels": {
+				Type:        schema.TypeMap,
+				Computed:    true,
+				Optional:    true,
+				Description: `User-defined labels for the edgecloud cluster.`,
+				Elem:        &schema.Schema{Type: schema.TypeString},
+			},
+			"maintenance_policy": {
+				Type:        schema.TypeList,
+				Computed:    true,
+				Optional:    true,
+				Description: `Cluster-wide maintenance policy configuration.`,
+				MaxItems:    1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"window": {
+							Type:        schema.TypeList,
+							Required:    true,
+							Description: `Specifies the maintenance window in which maintenance may be performed.`,
+							MaxItems:    1,
+							Elem: &schema.Resource{
+								Schema: map[string]*schema.Schema{
+									"recurring_window": {
+										Type:        schema.TypeList,
+										Required:    true,
+										Description: `Represents an arbitrary window of time that recurs.`,
+										MaxItems:    1,
+										Elem: &schema.Resource{
+											Schema: map[string]*schema.Schema{
+												"recurrence": {
+													Type:     schema.TypeString,
+													Computed: true,
+													Optional: true,
+													Description: `An RRULE (https://tools.ietf.org/html/rfc5545#section-3.8.5.3) for how
+this window recurs. They go on for the span of time between the start and
+end time.`,
+												},
+												"window": {
+													Type:        schema.TypeList,
+													Computed:    true,
+													Optional:    true,
+													Description: `Represents an arbitrary window of time.`,
+													MaxItems:    1,
+													Elem: &schema.Resource{
+														Schema: map[string]*schema.Schema{
+															"end_time": {
+																Type:     schema.TypeString,
+																Computed: true,
+																Optional: true,
+																Description: `The time that the window ends. The end time must take place after the
+start time.`,
+															},
+															"start_time": {
+																Type:        schema.TypeString,
+																Computed:    true,
+																Optional:    true,
+																Description: `The time that the window first starts.`,
+															},
+														},
+													},
+												},
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			"release_channel": {
+				Type:         schema.TypeString,
+				Computed:     true,
+				Optional:     true,
+				ValidateFunc: verify.ValidateEnum([]string{"RELEASE_CHANNEL_UNSPECIFIED", "NONE", "REGULAR", ""}),
+				Description:  `The release channel a cluster is subscribed to. Possible values: ["RELEASE_CHANNEL_UNSPECIFIED", "NONE", "REGULAR"]`,
+			},
+			"system_addons_config": {
+				Type:        schema.TypeList,
+				Computed:    true,
+				Optional:    true,
+				Description: `Config that customers are allowed to define for GDCE system add-ons.`,
+				MaxItems:    1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"ingress": {
+							Type:     schema.TypeList,
+							Computed: true,
+							Optional: true,
+							Description: `Config for the Ingress add-on which allows customers to create an Ingress
+object to manage external access to the servers in a cluster. The add-on
+consists of istiod and istio-ingress.`,
+							MaxItems: 1,
+							Elem: &schema.Resource{
+								Schema: map[string]*schema.Schema{
+									"disabled": {
+										Type:        schema.TypeBool,
+										Computed:    true,
+										Optional:    true,
+										Description: `Whether Ingress is disabled.`,
+									},
+									"ipv4_vip": {
+										Type:        schema.TypeString,
+										Computed:    true,
+										Optional:    true,
+										Description: `Ingress VIP.`,
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			"target_version": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Optional:    true,
+				Description: `The target cluster version. For example: "1.5.0".`,
+			},
+			"cluster_ca_certificate": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The PEM-encoded public certificate of the cluster's CA.`,
+				Sensitive:   true,
+			},
+			"control_plane_version": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The control plane release version.`,
+			},
+			"create_time": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The time the cluster was created, in RFC3339 text format.`,
+			},
+			"endpoint": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The IP address of the Kubernetes API server.`,
+			},
+			"maintenance_events": {
+				Type:     schema.TypeList,
+				Computed: true,
+				Description: `All the maintenance events scheduled for the cluster, including the ones
+ongoing, planned for the future and done in the past (up to 90 days).`,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"create_time": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `The time when the maintenance event request was created.`,
+						},
+						"end_time": {
+							Type:     schema.TypeString,
+							Computed: true,
+							Description: `The time when the maintenance event ended, either successfully or not. If
+the maintenance event is split into multiple maintenance windows,
+end_time is only updated when the whole flow ends.`,
+						},
+						"operation": {
+							Type:     schema.TypeString,
+							Computed: true,
+							Description: `The operation for running the maintenance event. Specified in the format
+projects/*/locations/*/operations/*. If the maintenance event is split
+into multiple operations (e.g. due to maintenance windows), the latest
+one is recorded.`,
+						},
+						"schedule": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `The schedule of the maintenance event.`,
+						},
+						"start_time": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `The time when the maintenance event started.`,
+						},
+						"state": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `Indicates the maintenance event state.`,
+						},
+						"target_version": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `The target version of the cluster.`,
+						},
+						"type": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `Indicates the maintenance event type.`,
+						},
+						"update_time": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `The time when the maintenance event message was updated.`,
+						},
+						"uuid": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `UUID of the maintenance event.`,
+						},
+					},
+				},
+			},
+			"node_version": {
+				Type:     schema.TypeString,
+				Computed: true,
+				Description: `The lowest release version among all worker nodes. This field can be empty
+if the cluster does not have any worker nodes.`,
+			},
+			"port": {
+				Type:        schema.TypeInt,
+				Computed:    true,
+				Description: `The port number of the Kubernetes API server.`,
+			},
+			"status": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `Indicates the status of the cluster.`,
+			},
+			"update_time": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The time the cluster was last updated, in RFC3339 text format.`,
+			},
+			"project": {
+				Type:     schema.TypeString,
+				Optional: true,
+				Computed: true,
+				ForceNew: true,
+			},
+		},
+		UseJSONNumber: true,
+	}
+}
+
+func resourceEdgecontainerClusterCreate(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	obj := make(map[string]interface{})
+    labelsProp, err := expandEdgecontainerClusterLabels(d.Get("labels"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
+		obj["labels"] = labelsProp
+	}
+	fleetProp, err := expandEdgecontainerClusterFleet(d.Get("fleet"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("fleet"); !tpgresource.IsEmptyValue(reflect.ValueOf(fleetProp)) && (ok || !reflect.DeepEqual(v, fleetProp)) {
+		obj["fleet"] = fleetProp
+	}
+	networkingProp, err := expandEdgecontainerClusterNetworking(d.Get("networking"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("networking"); !tpgresource.IsEmptyValue(reflect.ValueOf(networkingProp)) && (ok || !reflect.DeepEqual(v, networkingProp)) {
+		obj["networking"] = networkingProp
+	}
+	authorizationProp, err := expandEdgecontainerClusterAuthorization(d.Get("authorization"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("authorization"); !tpgresource.IsEmptyValue(reflect.ValueOf(authorizationProp)) && (ok || !reflect.DeepEqual(v, authorizationProp)) {
+		obj["authorization"] = authorizationProp
+	}
+	defaultMaxPodsPerNodeProp, err := expandEdgecontainerClusterDefaultMaxPodsPerNode(d.Get("default_max_pods_per_node"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("default_max_pods_per_node"); !tpgresource.IsEmptyValue(reflect.ValueOf(defaultMaxPodsPerNodeProp)) && (ok || !reflect.DeepEqual(v, defaultMaxPodsPerNodeProp)) {
+		obj["defaultMaxPodsPerNode"] = defaultMaxPodsPerNodeProp
+	}
+	maintenancePolicyProp, err := expandEdgecontainerClusterMaintenancePolicy(d.Get("maintenance_policy"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("maintenance_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(maintenancePolicyProp)) && (ok || !reflect.DeepEqual(v, maintenancePolicyProp)) {
+		obj["maintenancePolicy"] = maintenancePolicyProp
+	}
+	controlPlaneProp, err := expandEdgecontainerClusterControlPlane(d.Get("control_plane"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("control_plane"); !tpgresource.IsEmptyValue(reflect.ValueOf(controlPlaneProp)) && (ok || !reflect.DeepEqual(v, controlPlaneProp)) {
+		obj["controlPlane"] = controlPlaneProp
+	}
+	systemAddonsConfigProp, err := expandEdgecontainerClusterSystemAddonsConfig(d.Get("system_addons_config"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("system_addons_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(systemAddonsConfigProp)) && (ok || !reflect.DeepEqual(v, systemAddonsConfigProp)) {
+		obj["systemAddonsConfig"] = systemAddonsConfigProp
+	}
+	externalLoadBalancerIpv4AddressPoolsProp, err := expandEdgecontainerClusterExternalLoadBalancerIpv4AddressPools(d.Get("external_load_balancer_ipv4_address_pools"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("external_load_balancer_ipv4_address_pools"); !tpgresource.IsEmptyValue(reflect.ValueOf(externalLoadBalancerIpv4AddressPoolsProp)) && (ok || !reflect.DeepEqual(v, externalLoadBalancerIpv4AddressPoolsProp)) {
+		obj["externalLoadBalancerIpv4AddressPools"] = externalLoadBalancerIpv4AddressPoolsProp
+	}
+	controlPlaneEncryptionProp, err := expandEdgecontainerClusterControlPlaneEncryption(d.Get("control_plane_encryption"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("control_plane_encryption"); !tpgresource.IsEmptyValue(reflect.ValueOf(controlPlaneEncryptionProp)) && (ok || !reflect.DeepEqual(v, controlPlaneEncryptionProp)) {
+		obj["controlPlaneEncryption"] = controlPlaneEncryptionProp
+	}
+	targetVersionProp, err := expandEdgecontainerClusterTargetVersion(d.Get("target_version"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("target_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(targetVersionProp)) && (ok || !reflect.DeepEqual(v, targetVersionProp)) {
+		obj["targetVersion"] = targetVersionProp
+	}
+	releaseChannelProp, err := expandEdgecontainerClusterReleaseChannel(d.Get("release_channel"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("release_channel"); !tpgresource.IsEmptyValue(reflect.ValueOf(releaseChannelProp)) && (ok || !reflect.DeepEqual(v, releaseChannelProp)) {
+		obj["releaseChannel"] = releaseChannelProp
+	}
+	
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters?cluster_id={{name}}")
+	if err != nil {
+		return err
+	}
+
+	log.Printf("[DEBUG] Creating new Cluster: %#v", obj)
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for Cluster: %s", err)
+	}
+	billingProject = project
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "POST",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+		Body:      obj,
+		Timeout:   d.Timeout(schema.TimeoutCreate),
+	})
+	if err != nil {
+		return fmt.Errorf("Error creating Cluster: %s", err)
+	}
+
+	// Store the ID now
+	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/clusters/{{name}}")
+	if err != nil {
+		return fmt.Errorf("Error constructing id: %s", err)
+	}
+	d.SetId(id)
+
+	err = EdgecontainerOperationWaitTime(
+		config, res, project, "Creating Cluster", userAgent,
+		d.Timeout(schema.TimeoutCreate))
+
+	if err != nil {
+		// The resource didn't actually create
+		d.SetId("")
+		return fmt.Errorf("Error waiting to create Cluster: %s", err)
+	}
+
+	log.Printf("[DEBUG] Finished creating Cluster %q: %#v", d.Id(), res)
+
+	return resourceEdgecontainerClusterRead(d, meta)
+}
+
+func resourceEdgecontainerClusterRead(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{name}}")
+	if err != nil {
+		return err
+	}
+
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for Cluster: %s", err)
+	}
+	billingProject = project
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "GET",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+	})
+	if err != nil {
+		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("EdgecontainerCluster %q", d.Id()))
+	}
+
+	if err := d.Set("project", project); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+
+	if err := d.Set("create_time", flattenEdgecontainerClusterCreateTime(res["createTime"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("update_time", flattenEdgecontainerClusterUpdateTime(res["updateTime"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("labels", flattenEdgecontainerClusterLabels(res["labels"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("fleet", flattenEdgecontainerClusterFleet(res["fleet"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("networking", flattenEdgecontainerClusterNetworking(res["networking"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("authorization", flattenEdgecontainerClusterAuthorization(res["authorization"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("default_max_pods_per_node", flattenEdgecontainerClusterDefaultMaxPodsPerNode(res["defaultMaxPodsPerNode"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("endpoint", flattenEdgecontainerClusterEndpoint(res["endpoint"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("port", flattenEdgecontainerClusterPort(res["port"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("cluster_ca_certificate", flattenEdgecontainerClusterClusterCaCertificate(res["clusterCaCertificate"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("maintenance_policy", flattenEdgecontainerClusterMaintenancePolicy(res["maintenancePolicy"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("control_plane_version", flattenEdgecontainerClusterControlPlaneVersion(res["controlPlaneVersion"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("node_version", flattenEdgecontainerClusterNodeVersion(res["nodeVersion"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("control_plane", flattenEdgecontainerClusterControlPlane(res["controlPlane"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("system_addons_config", flattenEdgecontainerClusterSystemAddonsConfig(res["systemAddonsConfig"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("external_load_balancer_ipv4_address_pools", flattenEdgecontainerClusterExternalLoadBalancerIpv4AddressPools(res["externalLoadBalancerIpv4AddressPools"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("control_plane_encryption", flattenEdgecontainerClusterControlPlaneEncryption(res["controlPlaneEncryption"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("status", flattenEdgecontainerClusterStatus(res["status"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("maintenance_events", flattenEdgecontainerClusterMaintenanceEvents(res["maintenanceEvents"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("target_version", flattenEdgecontainerClusterTargetVersion(res["targetVersion"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	if err := d.Set("release_channel", flattenEdgecontainerClusterReleaseChannel(res["releaseChannel"], d, config)); err != nil {
+		return fmt.Errorf("Error reading Cluster: %s", err)
+	}
+	
+	return nil
+}
+
+func resourceEdgecontainerClusterUpdate(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for Cluster: %s", err)
+	}
+	billingProject = project
+
+	obj := make(map[string]interface{})
+    labelsProp, err := expandEdgecontainerClusterLabels(d.Get("labels"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
+		obj["labels"] = labelsProp
+	}
+	fleetProp, err := expandEdgecontainerClusterFleet(d.Get("fleet"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("fleet"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, fleetProp)) {
+		obj["fleet"] = fleetProp
+	}
+	networkingProp, err := expandEdgecontainerClusterNetworking(d.Get("networking"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("networking"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, networkingProp)) {
+		obj["networking"] = networkingProp
+	}
+    authorizationProp, err := expandEdgecontainerClusterAuthorization(d.Get("authorization"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("authorization"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, authorizationProp)) {
+		obj["authorization"] = authorizationProp
+	}
+	defaultMaxPodsPerNodeProp, err := expandEdgecontainerClusterDefaultMaxPodsPerNode(d.Get("default_max_pods_per_node"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("default_max_pods_per_node"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, defaultMaxPodsPerNodeProp)) {
+		obj["defaultMaxPodsPerNode"] = defaultMaxPodsPerNodeProp
+	}
+	maintenancePolicyProp, err := expandEdgecontainerClusterMaintenancePolicy(d.Get("maintenance_policy"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("maintenance_policy"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, maintenancePolicyProp)) {
+		obj["maintenancePolicy"] = maintenancePolicyProp
+	}
+	controlPlaneProp, err := expandEdgecontainerClusterControlPlane(d.Get("control_plane"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("control_plane"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, controlPlaneProp)) {
+		obj["controlPlane"] = controlPlaneProp
+	}
+	systemAddonsConfigProp, err := expandEdgecontainerClusterSystemAddonsConfig(d.Get("system_addons_config"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("system_addons_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, systemAddonsConfigProp)) {
+		obj["systemAddonsConfig"] = systemAddonsConfigProp
+	}
+	externalLoadBalancerIpv4AddressPoolsProp, err := expandEdgecontainerClusterExternalLoadBalancerIpv4AddressPools(d.Get("external_load_balancer_ipv4_address_pools"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("external_load_balancer_ipv4_address_pools"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, externalLoadBalancerIpv4AddressPoolsProp)) {
+		obj["externalLoadBalancerIpv4AddressPools"] = externalLoadBalancerIpv4AddressPoolsProp
+	}
+	controlPlaneEncryptionProp, err := expandEdgecontainerClusterControlPlaneEncryption(d.Get("control_plane_encryption"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("control_plane_encryption"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, controlPlaneEncryptionProp)) {
+		obj["controlPlaneEncryption"] = controlPlaneEncryptionProp
+	}
+	releaseChannelProp, err := expandEdgecontainerClusterReleaseChannel(d.Get("release_channel"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("release_channel"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, releaseChannelProp)) {
+		obj["releaseChannel"] = releaseChannelProp
+	}
+	
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{name}}")
+	if err != nil {
+		return err
+	}
+
+	log.Printf("[DEBUG] Updating Cluster %q: %#v", d.Id(), obj)
+	updateMask := []string{}
+
+	if d.HasChange("networking") {
+		updateMask = append(updateMask, "networking")
+	}
+
+	if d.HasChange("default_max_pods_per_node") {
+		updateMask = append(updateMask, "defaultMaxPodsPerNode")
+	}
+
+	if d.HasChange("maintenance_policy") {
+		updateMask = append(updateMask, "maintenancePolicy")
+	}
+
+	if d.HasChange("control_plane") {
+		updateMask = append(updateMask, "controlPlane")
+	}
+
+	if d.HasChange("system_addons_config") {
+		updateMask = append(updateMask, "systemAddonsConfig")
+	}
+
+	if d.HasChange("external_load_balancer_ipv4_address_pools") {
+		updateMask = append(updateMask, "externalLoadBalancerIpv4AddressPools")
+	}
+
+	if d.HasChange("control_plane_encryption") {
+		updateMask = append(updateMask, "controlPlaneEncryption")
+	}
+
+	if d.HasChange("release_channel") {
+		updateMask = append(updateMask, "releaseChannel")
+	}
+
+	if d.HasChange("labels") {
+		updateMask = append(updateMask, "labels")
+	}
+	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
+	// won't set it
+	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
+	if err != nil {
+		return err
+	}
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	// if updateMask is empty we are not updating anything so skip the post
+	if len(updateMask) > 0 {
+		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+			Config:    config,
+			Method:    "PATCH",
+			Project:   billingProject,
+			RawURL:    url,
+			UserAgent: userAgent,
+			Body:      obj,
+			Timeout:   d.Timeout(schema.TimeoutUpdate),
+		})
+
+		if err != nil {
+			return fmt.Errorf("Error updating Cluster %q: %s", d.Id(), err)
+		} else {
+			log.Printf("[DEBUG] Finished updating Cluster %q: %#v", d.Id(), res)
+		}
+
+		err = EdgecontainerOperationWaitTime(
+			config, res, project, "Updating Cluster", userAgent,
+			d.Timeout(schema.TimeoutUpdate))
+
+		if err != nil {
+			return err
+		}
+	}
+	d.Partial(true)
+
+	if d.HasChange("target_version") {
+		obj := make(map[string]interface{})
+
+		targetVersionProp, err := expandEdgecontainerClusterTargetVersion(d.Get("target_version"), d, config)
+		if err != nil {
+			return err
+		} else if v, ok := d.GetOkExists("target_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, targetVersionProp)) {
+			obj["targetVersion"] = targetVersionProp
+		}
+
+		url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{name}}:upgrade")
+		if err != nil {
+			return err
+		}
+
+		// err == nil indicates that the billing_project value was found
+		if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+			billingProject = bp
+		}
+
+		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+			Config:    config,
+			Method:    "POST",
+			Project:   billingProject,
+			RawURL:    url,
+			UserAgent: userAgent,
+			Body:      obj,
+			Timeout:   d.Timeout(schema.TimeoutUpdate),
+		})
+		if err != nil {
+			return fmt.Errorf("Error updating Cluster %q: %s", d.Id(), err)
+		} else {
+			log.Printf("[DEBUG] Finished updating Cluster %q: %#v", d.Id(), res)
+		}
+
+		err = EdgecontainerOperationWaitTime(
+			config, res, project, "Updating Cluster", userAgent,
+			d.Timeout(schema.TimeoutUpdate))
+		if err != nil {
+			return err
+		}
+	}
+
+	d.Partial(false)
+
+	return resourceEdgecontainerClusterRead(d, meta)
+}
+
+func resourceEdgecontainerClusterDelete(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for Cluster: %s", err)
+	}
+	billingProject = project
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{name}}")
+	if err != nil {
+		return err
+	}
+
+	var obj map[string]interface{}
+	log.Printf("[DEBUG] Deleting Cluster %q", d.Id())
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "DELETE",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+		Body:      obj,
+		Timeout:   d.Timeout(schema.TimeoutDelete),
+	})
+	if err != nil {
+		return transport_tpg.HandleNotFoundError(err, d, "Cluster")
+	}
+
+	err = EdgecontainerOperationWaitTime(
+		config, res, project, "Deleting Cluster", userAgent,
+		d.Timeout(schema.TimeoutDelete))
+
+	if err != nil {
+		return err
+	}
+
+	log.Printf("[DEBUG] Finished deleting Cluster %q: %#v", d.Id(), res)
+	return nil
+}
+
+func resourceEdgecontainerClusterImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
+	config := meta.(*transport_tpg.Config)
+	if err := tpgresource.ParseImportId([]string{
+		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/clusters/(?P<name>[^/]+)$",
+		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
+		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
+	}, d, config); err != nil {
+		return nil, err
+	}
+
+	// Replace import id for the resource id
+	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/clusters/{{name}}")
+	if err != nil {
+		return nil, fmt.Errorf("Error constructing id: %s", err)
+	}
+	d.SetId(id)
+
+	return []*schema.ResourceData{d}, nil
+}
+
+func flattenEdgecontainerClusterCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+			return v
+}
+
+func flattenEdgecontainerClusterFleet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["project"] =
+		flattenEdgecontainerClusterFleetProject(original["project"], d, config)
+	transformed["membership"] =
+		flattenEdgecontainerClusterFleetMembership(original["membership"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterFleetProject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterFleetMembership(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterNetworking(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["cluster_ipv4_cidr_blocks"] =
+		flattenEdgecontainerClusterNetworkingClusterIpv4CidrBlocks(original["clusterIpv4CidrBlocks"], d, config)
+	transformed["services_ipv4_cidr_blocks"] =
+		flattenEdgecontainerClusterNetworkingServicesIpv4CidrBlocks(original["servicesIpv4CidrBlocks"], d, config)
+	transformed["cluster_ipv6_cidr_blocks"] =
+		flattenEdgecontainerClusterNetworkingClusterIpv6CidrBlocks(original["clusterIpv6CidrBlocks"], d, config)
+	transformed["services_ipv6_cidr_blocks"] =
+		flattenEdgecontainerClusterNetworkingServicesIpv6CidrBlocks(original["servicesIpv6CidrBlocks"], d, config)
+	transformed["network_type"] =
+		flattenEdgecontainerClusterNetworkingNetworkType(original["networkType"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterNetworkingClusterIpv4CidrBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterNetworkingServicesIpv4CidrBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterNetworkingClusterIpv6CidrBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterNetworkingServicesIpv6CidrBlocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterNetworkingNetworkType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterAuthorization(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["admin_users"] =
+		flattenEdgecontainerClusterAuthorizationAdminUsers(original["adminUsers"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterAuthorizationAdminUsers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["username"] =
+		flattenEdgecontainerClusterAuthorizationAdminUsersUsername(original["username"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterAuthorizationAdminUsersUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterDefaultMaxPodsPerNode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	// Handles the string fixed64 format
+	if strVal, ok := v.(string); ok {
+		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
+			return intVal
+		}
+	}
+
+	// number values are represented as float64
+	if floatVal, ok := v.(float64); ok {
+		intVal := int(floatVal)
+		return intVal
+	}
+
+	return v // let terraform core handle it otherwise
+}
+
+func flattenEdgecontainerClusterEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	// Handles the string fixed64 format
+	if strVal, ok := v.(string); ok {
+		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
+			return intVal
+		}
+	}
+
+	// number values are represented as float64
+	if floatVal, ok := v.(float64); ok {
+		intVal := int(floatVal)
+		return intVal
+	}
+
+	return v // let terraform core handle it otherwise
+}
+
+func flattenEdgecontainerClusterClusterCaCertificate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenancePolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["window"] =
+		flattenEdgecontainerClusterMaintenancePolicyWindow(original["window"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterMaintenancePolicyWindow(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["recurring_window"] =
+		flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindow(original["recurringWindow"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindow(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["window"] =
+		flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindow(original["window"], d, config)
+	transformed["recurrence"] =
+		flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindowRecurrence(original["recurrence"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindow(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["start_time"] =
+		flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindowStartTime(original["startTime"], d, config)
+	transformed["end_time"] =
+		flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindowEndTime(original["endTime"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindowStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindowEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenancePolicyWindowRecurringWindowRecurrence(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterControlPlaneVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterNodeVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterControlPlane(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["remote"] =
+		flattenEdgecontainerClusterControlPlaneRemote(original["remote"], d, config)
+	transformed["local"] =
+		flattenEdgecontainerClusterControlPlaneLocal(original["local"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterControlPlaneRemote(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["node_location"] =
+		flattenEdgecontainerClusterControlPlaneRemoteNodeLocation(original["nodeLocation"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterControlPlaneRemoteNodeLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterControlPlaneLocal(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["node_location"] =
+		flattenEdgecontainerClusterControlPlaneLocalNodeLocation(original["nodeLocation"], d, config)
+	transformed["node_count"] =
+		flattenEdgecontainerClusterControlPlaneLocalNodeCount(original["nodeCount"], d, config)
+	transformed["machine_filter"] =
+		flattenEdgecontainerClusterControlPlaneLocalMachineFilter(original["machineFilter"], d, config)
+	transformed["shared_deployment_policy"] =
+		flattenEdgecontainerClusterControlPlaneLocalSharedDeploymentPolicy(original["sharedDeploymentPolicy"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterControlPlaneLocalNodeLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterControlPlaneLocalNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	// Handles the string fixed64 format
+	if strVal, ok := v.(string); ok {
+		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
+			return intVal
+		}
+	}
+
+	// number values are represented as float64
+	if floatVal, ok := v.(float64); ok {
+		intVal := int(floatVal)
+		return intVal
+	}
+
+	return v // let terraform core handle it otherwise
+}
+
+func flattenEdgecontainerClusterControlPlaneLocalMachineFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterControlPlaneLocalSharedDeploymentPolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterSystemAddonsConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["ingress"] =
+		flattenEdgecontainerClusterSystemAddonsConfigIngress(original["ingress"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterSystemAddonsConfigIngress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["disabled"] =
+		flattenEdgecontainerClusterSystemAddonsConfigIngressDisabled(original["disabled"], d, config)
+	transformed["ipv4_vip"] =
+		flattenEdgecontainerClusterSystemAddonsConfigIngressIpv4Vip(original["ipv4Vip"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterSystemAddonsConfigIngressDisabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterSystemAddonsConfigIngressIpv4Vip(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterExternalLoadBalancerIpv4AddressPools(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterControlPlaneEncryption(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["kms_key"] =
+		flattenEdgecontainerClusterControlPlaneEncryptionKmsKey(original["kmsKey"], d, config)
+	transformed["kms_key_active_version"] =
+		flattenEdgecontainerClusterControlPlaneEncryptionKmsKeyActiveVersion(original["kmsKeyActiveVersion"], d, config)
+	transformed["kms_key_state"] =
+		flattenEdgecontainerClusterControlPlaneEncryptionKmsKeyState(original["kmsKeyState"], d, config)
+	transformed["kms_status"] =
+		flattenEdgecontainerClusterControlPlaneEncryptionKmsStatus(original["kmsStatus"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterControlPlaneEncryptionKmsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterControlPlaneEncryptionKmsKeyActiveVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterControlPlaneEncryptionKmsKeyState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterControlPlaneEncryptionKmsStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["code"] =
+		flattenEdgecontainerClusterControlPlaneEncryptionKmsStatusCode(original["code"], d, config)
+	transformed["message"] =
+		flattenEdgecontainerClusterControlPlaneEncryptionKmsStatusMessage(original["message"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerClusterControlPlaneEncryptionKmsStatusCode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	// Handles the string fixed64 format
+	if strVal, ok := v.(string); ok {
+		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
+			return intVal
+		}
+	}
+
+	// number values are represented as float64
+	if floatVal, ok := v.(float64); ok {
+		intVal := int(floatVal)
+		return intVal
+	}
+
+	return v // let terraform core handle it otherwise
+}
+
+func flattenEdgecontainerClusterControlPlaneEncryptionKmsStatusMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEvents(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return v
+	}
+	l := v.([]interface{})
+	transformed := make([]interface{}, 0, len(l))
+	for _, raw := range l {
+		original := raw.(map[string]interface{})
+		if len(original) < 1 {
+			// Do not include empty json objects coming back from the api
+			continue
+		}
+		transformed = append(transformed, map[string]interface{}{
+			"uuid":           flattenEdgecontainerClusterMaintenanceEventsUuid(original["uuid"], d, config),
+			"target_version": flattenEdgecontainerClusterMaintenanceEventsTargetVersion(original["targetVersion"], d, config),
+			"operation":      flattenEdgecontainerClusterMaintenanceEventsOperation(original["operation"], d, config),
+			"type":           flattenEdgecontainerClusterMaintenanceEventsType(original["type"], d, config),
+			"schedule":       flattenEdgecontainerClusterMaintenanceEventsSchedule(original["schedule"], d, config),
+			"state":          flattenEdgecontainerClusterMaintenanceEventsState(original["state"], d, config),
+			"create_time":    flattenEdgecontainerClusterMaintenanceEventsCreateTime(original["createTime"], d, config),
+			"start_time":     flattenEdgecontainerClusterMaintenanceEventsStartTime(original["startTime"], d, config),
+			"end_time":       flattenEdgecontainerClusterMaintenanceEventsEndTime(original["endTime"], d, config),
+			"update_time":    flattenEdgecontainerClusterMaintenanceEventsUpdateTime(original["updateTime"], d, config),
+		})
+	}
+	return transformed
+}
+func flattenEdgecontainerClusterMaintenanceEventsUuid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEventsTargetVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEventsOperation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEventsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEventsSchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEventsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEventsCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEventsStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEventsEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterMaintenanceEventsUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterTargetVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerClusterReleaseChannel(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func expandEdgecontainerClusterLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
+	if v == nil {
+		return map[string]string{}, nil
+	}
+	m := make(map[string]string)
+	for k, val := range v.(map[string]interface{}) {
+			m[k] = val.(string)
+	}
+	return m, nil
+}
+
+func expandEdgecontainerClusterFleet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedProject, err := expandEdgecontainerClusterFleetProject(original["project"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedProject); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["project"] = transformedProject
+	}
+
+	transformedMembership, err := expandEdgecontainerClusterFleetMembership(original["membership"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedMembership); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["membership"] = transformedMembership
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterFleetProject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterFleetMembership(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterNetworking(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedClusterIpv4CidrBlocks, err := expandEdgecontainerClusterNetworkingClusterIpv4CidrBlocks(original["cluster_ipv4_cidr_blocks"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedClusterIpv4CidrBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["clusterIpv4CidrBlocks"] = transformedClusterIpv4CidrBlocks
+	}
+
+	transformedServicesIpv4CidrBlocks, err := expandEdgecontainerClusterNetworkingServicesIpv4CidrBlocks(original["services_ipv4_cidr_blocks"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedServicesIpv4CidrBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["servicesIpv4CidrBlocks"] = transformedServicesIpv4CidrBlocks
+	}
+
+	transformedClusterIpv6CidrBlocks, err := expandEdgecontainerClusterNetworkingClusterIpv6CidrBlocks(original["cluster_ipv6_cidr_blocks"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedClusterIpv6CidrBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["clusterIpv6CidrBlocks"] = transformedClusterIpv6CidrBlocks
+	}
+
+	transformedServicesIpv6CidrBlocks, err := expandEdgecontainerClusterNetworkingServicesIpv6CidrBlocks(original["services_ipv6_cidr_blocks"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedServicesIpv6CidrBlocks); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["servicesIpv6CidrBlocks"] = transformedServicesIpv6CidrBlocks
+	}
+
+	transformedNetworkType, err := expandEdgecontainerClusterNetworkingNetworkType(original["network_type"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedNetworkType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["networkType"] = transformedNetworkType
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterNetworkingClusterIpv4CidrBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterNetworkingServicesIpv4CidrBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterNetworkingClusterIpv6CidrBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterNetworkingServicesIpv6CidrBlocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterNetworkingNetworkType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterAuthorization(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedAdminUsers, err := expandEdgecontainerClusterAuthorizationAdminUsers(original["admin_users"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedAdminUsers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["adminUsers"] = transformedAdminUsers
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterAuthorizationAdminUsers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedUsername, err := expandEdgecontainerClusterAuthorizationAdminUsersUsername(original["username"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["username"] = transformedUsername
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterAuthorizationAdminUsersUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterDefaultMaxPodsPerNode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterMaintenancePolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedWindow, err := expandEdgecontainerClusterMaintenancePolicyWindow(original["window"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedWindow); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["window"] = transformedWindow
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterMaintenancePolicyWindow(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedRecurringWindow, err := expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindow(original["recurring_window"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedRecurringWindow); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["recurringWindow"] = transformedRecurringWindow
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindow(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedWindow, err := expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindow(original["window"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedWindow); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["window"] = transformedWindow
+	}
+
+	transformedRecurrence, err := expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindowRecurrence(original["recurrence"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedRecurrence); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["recurrence"] = transformedRecurrence
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindow(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedStartTime, err := expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindowStartTime(original["start_time"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedStartTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["startTime"] = transformedStartTime
+	}
+
+	transformedEndTime, err := expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindowEndTime(original["end_time"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedEndTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["endTime"] = transformedEndTime
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindowStartTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindowWindowEndTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterMaintenancePolicyWindowRecurringWindowRecurrence(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlane(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedRemote, err := expandEdgecontainerClusterControlPlaneRemote(original["remote"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedRemote); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["remote"] = transformedRemote
+	}
+
+	transformedLocal, err := expandEdgecontainerClusterControlPlaneLocal(original["local"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedLocal); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["local"] = transformedLocal
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterControlPlaneRemote(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedNodeLocation, err := expandEdgecontainerClusterControlPlaneRemoteNodeLocation(original["node_location"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedNodeLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["nodeLocation"] = transformedNodeLocation
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterControlPlaneRemoteNodeLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlaneLocal(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedNodeLocation, err := expandEdgecontainerClusterControlPlaneLocalNodeLocation(original["node_location"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedNodeLocation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["nodeLocation"] = transformedNodeLocation
+	}
+
+	transformedNodeCount, err := expandEdgecontainerClusterControlPlaneLocalNodeCount(original["node_count"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["nodeCount"] = transformedNodeCount
+	}
+
+	transformedMachineFilter, err := expandEdgecontainerClusterControlPlaneLocalMachineFilter(original["machine_filter"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedMachineFilter); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["machineFilter"] = transformedMachineFilter
+	}
+
+	transformedSharedDeploymentPolicy, err := expandEdgecontainerClusterControlPlaneLocalSharedDeploymentPolicy(original["shared_deployment_policy"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedSharedDeploymentPolicy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["sharedDeploymentPolicy"] = transformedSharedDeploymentPolicy
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterControlPlaneLocalNodeLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlaneLocalNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlaneLocalMachineFilter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlaneLocalSharedDeploymentPolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterSystemAddonsConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedIngress, err := expandEdgecontainerClusterSystemAddonsConfigIngress(original["ingress"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedIngress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["ingress"] = transformedIngress
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterSystemAddonsConfigIngress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedDisabled, err := expandEdgecontainerClusterSystemAddonsConfigIngressDisabled(original["disabled"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedDisabled); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["disabled"] = transformedDisabled
+	}
+
+	transformedIpv4Vip, err := expandEdgecontainerClusterSystemAddonsConfigIngressIpv4Vip(original["ipv4_vip"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedIpv4Vip); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["ipv4Vip"] = transformedIpv4Vip
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterSystemAddonsConfigIngressDisabled(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterSystemAddonsConfigIngressIpv4Vip(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterExternalLoadBalancerIpv4AddressPools(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlaneEncryption(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedKmsKey, err := expandEdgecontainerClusterControlPlaneEncryptionKmsKey(original["kms_key"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedKmsKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["kmsKey"] = transformedKmsKey
+	}
+
+	transformedKmsKeyActiveVersion, err := expandEdgecontainerClusterControlPlaneEncryptionKmsKeyActiveVersion(original["kms_key_active_version"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedKmsKeyActiveVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["kmsKeyActiveVersion"] = transformedKmsKeyActiveVersion
+	}
+
+	transformedKmsKeyState, err := expandEdgecontainerClusterControlPlaneEncryptionKmsKeyState(original["kms_key_state"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedKmsKeyState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["kmsKeyState"] = transformedKmsKeyState
+	}
+
+	transformedKmsStatus, err := expandEdgecontainerClusterControlPlaneEncryptionKmsStatus(original["kms_status"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedKmsStatus); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["kmsStatus"] = transformedKmsStatus
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterControlPlaneEncryptionKmsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlaneEncryptionKmsKeyActiveVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlaneEncryptionKmsKeyState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlaneEncryptionKmsStatus(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedCode, err := expandEdgecontainerClusterControlPlaneEncryptionKmsStatusCode(original["code"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedCode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["code"] = transformedCode
+	}
+
+	transformedMessage, err := expandEdgecontainerClusterControlPlaneEncryptionKmsStatusMessage(original["message"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedMessage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["message"] = transformedMessage
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerClusterControlPlaneEncryptionKmsStatusCode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterControlPlaneEncryptionKmsStatusMessage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterTargetVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerClusterReleaseChannel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
\ No newline at end of file
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_cluster_generated_test.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_cluster_generated_test.go
new file mode 100644
index 000000000..d598e94c5
--- /dev/null
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_cluster_generated_test.go
@@ -0,0 +1,185 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+// ----------------------------------------------------------------------------
+//
+//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
+//
+// ----------------------------------------------------------------------------
+//
+//     This file is automatically generated by Magic Modules and manual
+//     changes will be clobbered when the file is regenerated.
+//
+//     Please read more about how to change this file in
+//     .github/CONTRIBUTING.md.
+//
+// ----------------------------------------------------------------------------
+
+package edgecontainer_test
+
+import (
+	"fmt"
+	"strings"
+	"testing"
+
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
+
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/acctest"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
+	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
+)
+
+func TestAccEdgecontainerCluster_edgecontainerClusterExample(t *testing.T) {
+	t.Parallel()
+
+	context := map[string]interface{}{
+		"random_suffix": acctest.RandString(t, 10),
+	}
+
+	acctest.VcrTest(t, resource.TestCase{
+		PreCheck:                 func() { acctest.AccTestPreCheck(t) },
+		ProtoV5ProviderFactories: acctest.ProtoV5ProviderFactories(t),
+		CheckDestroy:             testAccCheckEdgecontainerClusterDestroyProducer(t),
+		Steps: []resource.TestStep{
+			{
+				Config: testAccEdgecontainerCluster_edgecontainerClusterExample(context),
+			},
+			{
+				ResourceName:            "google_edgecontainer_cluster.default",
+				ImportState:             true,
+				ImportStateVerify:       true,
+				ImportStateVerifyIgnore: []string{"location", "name"},
+			},
+		},
+	})
+}
+
+func testAccEdgecontainerCluster_edgecontainerClusterExample(context map[string]interface{}) string {
+	return acctest.Nprintf(`
+resource "google_edgecontainer_cluster" "default" {
+  name = "tf-test-basic-cluster%{random_suffix}"
+  location = "us-central1"
+
+  authorization {
+    admin_users {
+      username = "admin@hashicorptest.com"
+    }
+  }
+
+  networking {
+    cluster_ipv4_cidr_blocks = ["10.0.0.0/16"]
+    services_ipv4_cidr_blocks = ["10.1.0.0/16"]
+  }
+
+  fleet {
+    project = "projects/${data.google_project.project.number}"
+  }
+}
+
+data "google_project" "project" {}
+`, context)
+}
+
+func TestAccEdgecontainerCluster_edgecontainerClusterWithMaintenanceWindowExample(t *testing.T) {
+	t.Parallel()
+
+	context := map[string]interface{}{
+		"random_suffix": acctest.RandString(t, 10),
+	}
+
+	acctest.VcrTest(t, resource.TestCase{
+		PreCheck:                 func() { acctest.AccTestPreCheck(t) },
+		ProtoV5ProviderFactories: acctest.ProtoV5ProviderFactories(t),
+		CheckDestroy:             testAccCheckEdgecontainerClusterDestroyProducer(t),
+		Steps: []resource.TestStep{
+			{
+				Config: testAccEdgecontainerCluster_edgecontainerClusterWithMaintenanceWindowExample(context),
+			},
+			{
+				ResourceName:            "google_edgecontainer_cluster.default",
+				ImportState:             true,
+				ImportStateVerify:       true,
+				ImportStateVerifyIgnore: []string{"location", "name"},
+			},
+		},
+	})
+}
+
+func testAccEdgecontainerCluster_edgecontainerClusterWithMaintenanceWindowExample(context map[string]interface{}) string {
+	return acctest.Nprintf(`
+resource "google_edgecontainer_cluster" "default" {
+  name = "tf-test-cluster-with-maintenance%{random_suffix}"
+  location = "us-central1"
+
+  authorization {
+    admin_users {
+      username = "admin@hashicorptest.com"
+    }
+  }
+
+  networking {
+    cluster_ipv4_cidr_blocks = ["10.0.0.0/16"]
+    services_ipv4_cidr_blocks = ["10.1.0.0/16"]
+  }
+
+  fleet {
+    project = "projects/${data.google_project.project.number}"
+  }
+
+  maintenance_policy {
+    window {
+      recurring_window {
+        window {
+          start_time = "2023-01-01T08:00:00Z"
+          end_time = "2023-01-01T17:00:00Z"
+        }
+
+        recurrence = "FREQ=WEEKLY;BYDAY=SA"
+      }
+    }
+  }
+}
+
+data "google_project" "project" {}
+`, context)
+}
+
+func testAccCheckEdgecontainerClusterDestroyProducer(t *testing.T) func(s *terraform.State) error {
+	return func(s *terraform.State) error {
+		for name, rs := range s.RootModule().Resources {
+			if rs.Type != "google_edgecontainer_cluster" {
+				continue
+			}
+			if strings.HasPrefix(name, "data.") {
+				continue
+			}
+
+			config := acctest.GoogleProviderConfig(t)
+
+			url, err := tpgresource.ReplaceVarsForTest(config, rs, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{name}}")
+			if err != nil {
+				return err
+			}
+
+			billingProject := ""
+
+			if config.BillingProject != "" {
+				billingProject = config.BillingProject
+			}
+
+			_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+				Config:    config,
+				Method:    "GET",
+				Project:   billingProject,
+				RawURL:    url,
+				UserAgent: config.UserAgent,
+			})
+			if err == nil {
+				return fmt.Errorf("EdgecontainerCluster still exists at %s", url)
+			}
+		}
+
+		return nil
+	}
+}
\ No newline at end of file
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_cluster_sweeper.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_cluster_sweeper.go
new file mode 100644
index 000000000..21159ac6c
--- /dev/null
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_cluster_sweeper.go
@@ -0,0 +1,139 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+// ----------------------------------------------------------------------------
+//
+//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
+//
+// ----------------------------------------------------------------------------
+//
+//     This file is automatically generated by Magic Modules and manual
+//     changes will be clobbered when the file is regenerated.
+//
+//     Please read more about how to change this file in
+//     .github/CONTRIBUTING.md.
+//
+// ----------------------------------------------------------------------------
+
+package edgecontainer
+
+import (
+	"context"
+	"log"
+	"strings"
+	"testing"
+
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/envvar"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/sweeper"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
+	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
+)
+
+func init() {
+	sweeper.AddTestSweepers("EdgecontainerCluster", testSweepEdgecontainerCluster)
+}
+
+// At the time of writing, the CI only passes us-central1 as the region
+func testSweepEdgecontainerCluster(region string) error {
+	resourceName := "EdgecontainerCluster"
+	log.Printf("[INFO][SWEEPER_LOG] Starting sweeper for %s", resourceName)
+
+	config, err := sweeper.SharedConfigForRegion(region)
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] error getting shared config for region: %s", err)
+		return err
+	}
+
+	err = config.LoadAndValidate(context.Background())
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] error loading: %s", err)
+		return err
+	}
+
+	t := &testing.T{}
+	billingId := envvar.GetTestBillingAccountFromEnv(t)
+
+	// Setup variables to replace in list template
+	d := &tpgresource.ResourceDataMock{
+		FieldsInSchema: map[string]interface{}{
+			"project":         config.Project,
+			"region":          region,
+			"location":        region,
+			"zone":            "-",
+			"billing_account": billingId,
+		},
+	}
+
+	listTemplate := strings.Split("https://edgecontainer.googleapis.com/v1/projects/{{project}}/locations/{{location}}/clusters", "?")[0]
+	listUrl, err := tpgresource.ReplaceVars(d, config, listTemplate)
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] error preparing sweeper list url: %s", err)
+		return nil
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "GET",
+		Project:   config.Project,
+		RawURL:    listUrl,
+		UserAgent: config.UserAgent,
+	})
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] Error in response from request %s: %s", listUrl, err)
+		return nil
+	}
+
+	resourceList, ok := res["clusters"]
+	if !ok {
+		log.Printf("[INFO][SWEEPER_LOG] Nothing found in response.")
+		return nil
+	}
+
+	rl := resourceList.([]interface{})
+
+	log.Printf("[INFO][SWEEPER_LOG] Found %d items in %s list response.", len(rl), resourceName)
+	// Keep count of items that aren't sweepable for logging.
+	nonPrefixCount := 0
+	for _, ri := range rl {
+		obj := ri.(map[string]interface{})
+		if obj["name"] == nil {
+			log.Printf("[INFO][SWEEPER_LOG] %s resource name was nil", resourceName)
+			return nil
+		}
+
+		name := tpgresource.GetResourceNameFromSelfLink(obj["name"].(string))
+		// Skip resources that shouldn't be sweeped
+		if !sweeper.IsSweepableTestResource(name) {
+			nonPrefixCount++
+			continue
+		}
+
+		deleteTemplate := "https://edgecontainer.googleapis.com/v1/projects/{{project}}/locations/{{location}}/clusters/{{name}}"
+		deleteUrl, err := tpgresource.ReplaceVars(d, config, deleteTemplate)
+		if err != nil {
+			log.Printf("[INFO][SWEEPER_LOG] error preparing delete url: %s", err)
+			return nil
+		}
+		deleteUrl = deleteUrl + name
+
+		// Don't wait on operations as we may have a lot to delete
+		_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+			Config:    config,
+			Method:    "DELETE",
+			Project:   config.Project,
+			RawURL:    deleteUrl,
+			UserAgent: config.UserAgent,
+		})
+		if err != nil {
+			log.Printf("[INFO][SWEEPER_LOG] Error deleting for url %s : %s", deleteUrl, err)
+		} else {
+			log.Printf("[INFO][SWEEPER_LOG] Sent delete request for %s resource: %s", resourceName, name)
+		}
+	}
+
+	if nonPrefixCount > 0 {
+		log.Printf("[INFO][SWEEPER_LOG] %d items were non-sweepable and skipped.", nonPrefixCount)
+	}
+
+	return nil
+}
\ No newline at end of file
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_node_pool.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_node_pool.go
new file mode 100644
index 000000000..308f7818f
--- /dev/null
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_node_pool.go
@@ -0,0 +1,716 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+// ----------------------------------------------------------------------------
+//
+//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
+//
+// ----------------------------------------------------------------------------
+//
+//     This file is automatically generated by Magic Modules and manual
+//     changes will be clobbered when the file is regenerated.
+//
+//     Please read more about how to change this file in
+//     .github/CONTRIBUTING.md.
+//
+// ----------------------------------------------------------------------------
+
+package edgecontainer
+
+import (
+	"fmt"
+	"log"
+	"reflect"
+	"strings"
+	"time"
+
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
+
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
+	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
+)
+
+func ResourceEdgecontainerNodePool() *schema.Resource {
+	return &schema.Resource{
+		Create: resourceEdgecontainerNodePoolCreate,
+		Read:   resourceEdgecontainerNodePoolRead,
+		Update: resourceEdgecontainerNodePoolUpdate,
+		Delete: resourceEdgecontainerNodePoolDelete,
+
+		Importer: &schema.ResourceImporter{
+			State: resourceEdgecontainerNodePoolImport,
+		},
+
+		Timeouts: &schema.ResourceTimeout{
+			Create: schema.DefaultTimeout(60 * time.Minute),
+			Update: schema.DefaultTimeout(60 * time.Minute),
+			Delete: schema.DefaultTimeout(60 * time.Minute),
+		},
+
+		Schema: map[string]*schema.Schema{
+			"cluster": {
+				Type:        schema.TypeString,
+				Required:    true,
+				ForceNew:    true,
+				Description: `The name of the target Distributed Cloud Edge Cluster.`,
+			},
+			"location": {
+				Type:        schema.TypeString,
+				Required:    true,
+				ForceNew:    true,
+				Description: `The location of the resource.`,
+			},
+			"name": {
+				Type:        schema.TypeString,
+				Required:    true,
+				ForceNew:    true,
+				Description: `The resource name of the node pool.`,
+			},
+			"node_count": {
+				Type:        schema.TypeInt,
+				Required:    true,
+				Description: `The number of nodes in the pool.`,
+			},
+			"node_location": {
+				Type:        schema.TypeString,
+				Required:    true,
+				ForceNew:    true,
+				Description: `Name of the Google Distributed Cloud Edge zone where this node pool will be created. For example: 'us-central1-edge-customer-a'.`,
+			},
+			"labels": {
+				Type:        schema.TypeMap,
+				Computed:    true,
+				Optional:    true,
+				Description: `Labels associated with this resource.`,
+				Elem:        &schema.Schema{Type: schema.TypeString},
+			},
+			"local_disk_encryption": {
+				Type:        schema.TypeList,
+				Optional:    true,
+				Description: `Local disk encryption options. This field is only used when enabling CMEK support.`,
+				MaxItems:    1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"kms_key": {
+							Type:     schema.TypeString,
+							Optional: true,
+							ForceNew: true,
+							Description: `The Cloud KMS CryptoKey e.g. projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey} to use for protecting node local disks.
+If not specified, a Google-managed key will be used instead.`,
+						},
+						"kms_key_active_version": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `The Cloud KMS CryptoKeyVersion currently in use for protecting node local disks. Only applicable if kmsKey is set.`,
+						},
+						"kms_key_state": {
+							Type:     schema.TypeString,
+							Computed: true,
+							Description: `Availability of the Cloud KMS CryptoKey. If not KEY_AVAILABLE, then nodes may go offline as they cannot access their local data.
+This can be caused by a lack of permissions to use the key, or if the key is disabled or deleted.`,
+						},
+					},
+				},
+			},
+			"machine_filter": {
+				Type:     schema.TypeString,
+				Computed: true,
+				Optional: true,
+				Description: `Only machines matching this filter will be allowed to join the node pool.
+The filtering language accepts strings like "name=<name>", and is
+documented in more detail in [AIP-160](https://google.aip.dev/160).`,
+			},
+			"node_config": {
+				Type:        schema.TypeList,
+				Computed:    true,
+				Optional:    true,
+				Description: `Configuration for each node in the NodePool`,
+				MaxItems:    1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"labels": {
+							Type:        schema.TypeMap,
+							Computed:    true,
+							Optional:    true,
+							Description: `"The Kubernetes node labels"`,
+							Elem:        &schema.Schema{Type: schema.TypeString},
+						},
+					},
+				},
+			},
+			"create_time": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The time when the node pool was created.`,
+			},
+			"node_version": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The lowest release version among all worker nodes.`,
+			},
+			"update_time": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The time when the node pool was last updated.`,
+			},
+			"project": {
+				Type:     schema.TypeString,
+				Optional: true,
+				Computed: true,
+				ForceNew: true,
+			},
+		},
+		UseJSONNumber: true,
+	}
+}
+
+func resourceEdgecontainerNodePoolCreate(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	obj := make(map[string]interface{})
+	labelsProp, err := expandEdgecontainerNodePoolLabels(d.Get("labels"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
+		obj["labels"] = labelsProp
+	}
+	nodeLocationProp, err := expandEdgecontainerNodePoolNodeLocation(d.Get("node_location"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("node_location"); !tpgresource.IsEmptyValue(reflect.ValueOf(nodeLocationProp)) && (ok || !reflect.DeepEqual(v, nodeLocationProp)) {
+		obj["nodeLocation"] = nodeLocationProp
+	}
+	nodeCountProp, err := expandEdgecontainerNodePoolNodeCount(d.Get("node_count"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("node_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(nodeCountProp)) && (ok || !reflect.DeepEqual(v, nodeCountProp)) {
+		obj["nodeCount"] = nodeCountProp
+	}
+	machineFilterProp, err := expandEdgecontainerNodePoolMachineFilter(d.Get("machine_filter"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("machine_filter"); !tpgresource.IsEmptyValue(reflect.ValueOf(machineFilterProp)) && (ok || !reflect.DeepEqual(v, machineFilterProp)) {
+		obj["machineFilter"] = machineFilterProp
+	}
+	localDiskEncryptionProp, err := expandEdgecontainerNodePoolLocalDiskEncryption(d.Get("local_disk_encryption"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("local_disk_encryption"); !tpgresource.IsEmptyValue(reflect.ValueOf(localDiskEncryptionProp)) && (ok || !reflect.DeepEqual(v, localDiskEncryptionProp)) {
+		obj["localDiskEncryption"] = localDiskEncryptionProp
+	}
+	nodeConfigProp, err := expandEdgecontainerNodePoolNodeConfig(d.Get("node_config"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("node_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(nodeConfigProp)) && (ok || !reflect.DeepEqual(v, nodeConfigProp)) {
+		obj["nodeConfig"] = nodeConfigProp
+	}
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/nodePools?nodePoolId={{name}}")
+	if err != nil {
+		return err
+	}
+
+	log.Printf("[DEBUG] Creating new NodePool: %#v", obj)
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for NodePool: %s", err)
+	}
+	billingProject = project
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "POST",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+		Body:      obj,
+		Timeout:   d.Timeout(schema.TimeoutCreate),
+	})
+	if err != nil {
+		return fmt.Errorf("Error creating NodePool: %s", err)
+	}
+
+	// Store the ID now
+	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/nodePools/{{name}}")
+	if err != nil {
+		return fmt.Errorf("Error constructing id: %s", err)
+	}
+	d.SetId(id)
+
+	err = EdgecontainerOperationWaitTime(
+		config, res, project, "Creating NodePool", userAgent,
+		d.Timeout(schema.TimeoutCreate))
+
+	if err != nil {
+		// The resource didn't actually create
+		d.SetId("")
+		return fmt.Errorf("Error waiting to create NodePool: %s", err)
+	}
+
+	log.Printf("[DEBUG] Finished creating NodePool %q: %#v", d.Id(), res)
+
+	return resourceEdgecontainerNodePoolRead(d, meta)
+}
+
+func resourceEdgecontainerNodePoolRead(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/nodePools/{{name}}")
+	if err != nil {
+		return err
+	}
+
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for NodePool: %s", err)
+	}
+	billingProject = project
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "GET",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+	})
+	if err != nil {
+		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("EdgecontainerNodePool %q", d.Id()))
+	}
+
+	if err := d.Set("project", project); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+
+	if err := d.Set("create_time", flattenEdgecontainerNodePoolCreateTime(res["createTime"], d, config)); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+	if err := d.Set("update_time", flattenEdgecontainerNodePoolUpdateTime(res["updateTime"], d, config)); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+	if err := d.Set("labels", flattenEdgecontainerNodePoolLabels(res["labels"], d, config)); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+	if err := d.Set("node_location", flattenEdgecontainerNodePoolNodeLocation(res["nodeLocation"], d, config)); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+	if err := d.Set("node_count", flattenEdgecontainerNodePoolNodeCount(res["nodeCount"], d, config)); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+	if err := d.Set("machine_filter", flattenEdgecontainerNodePoolMachineFilter(res["machineFilter"], d, config)); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+	if err := d.Set("local_disk_encryption", flattenEdgecontainerNodePoolLocalDiskEncryption(res["localDiskEncryption"], d, config)); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+	if err := d.Set("node_version", flattenEdgecontainerNodePoolNodeVersion(res["nodeVersion"], d, config)); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+	if err := d.Set("node_config", flattenEdgecontainerNodePoolNodeConfig(res["nodeConfig"], d, config)); err != nil {
+		return fmt.Errorf("Error reading NodePool: %s", err)
+	}
+
+	return nil
+}
+
+func resourceEdgecontainerNodePoolUpdate(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for NodePool: %s", err)
+	}
+	billingProject = project
+
+	obj := make(map[string]interface{})
+	labelsProp, err := expandEdgecontainerNodePoolLabels(d.Get("labels"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
+		obj["labels"] = labelsProp
+	}
+	nodeLocationProp, err := expandEdgecontainerNodePoolNodeLocation(d.Get("node_location"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("node_location"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nodeLocationProp)) {
+		obj["nodeLocation"] = nodeLocationProp
+	}
+	nodeCountProp, err := expandEdgecontainerNodePoolNodeCount(d.Get("node_count"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("node_count"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nodeCountProp)) {
+		obj["nodeCount"] = nodeCountProp
+	}
+	machineFilterProp, err := expandEdgecontainerNodePoolMachineFilter(d.Get("machine_filter"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("machine_filter"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, machineFilterProp)) {
+		obj["machineFilter"] = machineFilterProp
+	}
+	localDiskEncryptionProp, err := expandEdgecontainerNodePoolLocalDiskEncryption(d.Get("local_disk_encryption"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("local_disk_encryption"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, localDiskEncryptionProp)) {
+		obj["localDiskEncryption"] = localDiskEncryptionProp
+	}
+	nodeConfigProp, err := expandEdgecontainerNodePoolNodeConfig(d.Get("node_config"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("node_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nodeConfigProp)) {
+		obj["nodeConfig"] = nodeConfigProp
+	}
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/nodePools/{{name}}")
+	if err != nil {
+		return err
+	}
+
+	log.Printf("[DEBUG] Updating NodePool %q: %#v", d.Id(), obj)
+	updateMask := []string{}
+
+	if d.HasChange("node_count") {
+		updateMask = append(updateMask, "nodeCount")
+	}
+
+	if d.HasChange("machine_filter") {
+		updateMask = append(updateMask, "machineFilter")
+	}
+
+	if d.HasChange("local_disk_encryption") {
+		updateMask = append(updateMask, "localDiskEncryption")
+	}
+
+	if d.HasChange("node_config") {
+		updateMask = append(updateMask, "nodeConfig")
+	}
+
+	if d.HasChange("labels") {
+		updateMask = append(updateMask, "labels")
+	}
+
+	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
+	// won't set it
+	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
+	if err != nil {
+		return err
+	}
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	// if updateMask is empty we are not updating anything so skip the post
+	if len(updateMask) > 0 {
+		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+			Config:    config,
+			Method:    "PATCH",
+			Project:   billingProject,
+			RawURL:    url,
+			UserAgent: userAgent,
+			Body:      obj,
+			Timeout:   d.Timeout(schema.TimeoutUpdate),
+		})
+
+		if err != nil {
+			return fmt.Errorf("Error updating NodePool %q: %s", d.Id(), err)
+		} else {
+			log.Printf("[DEBUG] Finished updating NodePool %q: %#v", d.Id(), res)
+		}
+
+		err = EdgecontainerOperationWaitTime(
+			config, res, project, "Updating NodePool", userAgent,
+			d.Timeout(schema.TimeoutUpdate))
+
+		if err != nil {
+			return err
+		}
+	}
+
+	return resourceEdgecontainerNodePoolRead(d, meta)
+}
+
+func resourceEdgecontainerNodePoolDelete(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for NodePool: %s", err)
+	}
+	billingProject = project
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/nodePools/{{name}}")
+	if err != nil {
+		return err
+	}
+
+	var obj map[string]interface{}
+	log.Printf("[DEBUG] Deleting NodePool %q", d.Id())
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "DELETE",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+		Body:      obj,
+		Timeout:   d.Timeout(schema.TimeoutDelete),
+	})
+	if err != nil {
+		return transport_tpg.HandleNotFoundError(err, d, "NodePool")
+	}
+
+	err = EdgecontainerOperationWaitTime(
+		config, res, project, "Deleting NodePool", userAgent,
+		d.Timeout(schema.TimeoutDelete))
+
+	if err != nil {
+		return err
+	}
+
+	log.Printf("[DEBUG] Finished deleting NodePool %q: %#v", d.Id(), res)
+	return nil
+}
+
+func resourceEdgecontainerNodePoolImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
+	config := meta.(*transport_tpg.Config)
+	if err := tpgresource.ParseImportId([]string{
+		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/clusters/(?P<cluster>[^/]+)/nodePools/(?P<name>[^/]+)$",
+		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<cluster>[^/]+)/(?P<name>[^/]+)$",
+		"^(?P<location>[^/]+)/(?P<cluster>[^/]+)/(?P<name>[^/]+)$",
+	}, d, config); err != nil {
+		return nil, err
+	}
+
+	// Replace import id for the resource id
+	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/nodePools/{{name}}")
+	if err != nil {
+		return nil, fmt.Errorf("Error constructing id: %s", err)
+	}
+	d.SetId(id)
+
+	return []*schema.ResourceData{d}, nil
+}
+
+func flattenEdgecontainerNodePoolCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerNodePoolUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerNodePoolLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerNodePoolNodeLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerNodePoolNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	// Handles the string fixed64 format
+	if strVal, ok := v.(string); ok {
+		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
+			return intVal
+		}
+	}
+
+	// number values are represented as float64
+	if floatVal, ok := v.(float64); ok {
+		intVal := int(floatVal)
+		return intVal
+	}
+
+	return v // let terraform core handle it otherwise
+}
+
+func flattenEdgecontainerNodePoolMachineFilter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerNodePoolLocalDiskEncryption(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["kms_key"] =
+		flattenEdgecontainerNodePoolLocalDiskEncryptionKmsKey(original["kmsKey"], d, config)
+	transformed["kms_key_active_version"] =
+		flattenEdgecontainerNodePoolLocalDiskEncryptionKmsKeyActiveVersion(original["kmsKeyActiveVersion"], d, config)
+	transformed["kms_key_state"] =
+		flattenEdgecontainerNodePoolLocalDiskEncryptionKmsKeyState(original["kmsKeyState"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerNodePoolLocalDiskEncryptionKmsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerNodePoolLocalDiskEncryptionKmsKeyActiveVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerNodePoolLocalDiskEncryptionKmsKeyState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerNodePoolNodeVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerNodePoolNodeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["labels"] =
+		flattenEdgecontainerNodePoolNodeConfigLabels(original["labels"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerNodePoolNodeConfigLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func expandEdgecontainerNodePoolLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
+	if v == nil {
+		return map[string]string{}, nil
+	}
+	m := make(map[string]string)
+	for k, val := range v.(map[string]interface{}) {
+		m[k] = val.(string)
+	}
+	return m, nil
+}
+
+func expandEdgecontainerNodePoolNodeLocation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerNodePoolNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerNodePoolMachineFilter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerNodePoolLocalDiskEncryption(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedKmsKey, err := expandEdgecontainerNodePoolLocalDiskEncryptionKmsKey(original["kms_key"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedKmsKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["kmsKey"] = transformedKmsKey
+	}
+
+	transformedKmsKeyActiveVersion, err := expandEdgecontainerNodePoolLocalDiskEncryptionKmsKeyActiveVersion(original["kms_key_active_version"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedKmsKeyActiveVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["kmsKeyActiveVersion"] = transformedKmsKeyActiveVersion
+	}
+
+	transformedKmsKeyState, err := expandEdgecontainerNodePoolLocalDiskEncryptionKmsKeyState(original["kms_key_state"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedKmsKeyState); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["kmsKeyState"] = transformedKmsKeyState
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerNodePoolLocalDiskEncryptionKmsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerNodePoolLocalDiskEncryptionKmsKeyActiveVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerNodePoolLocalDiskEncryptionKmsKeyState(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerNodePoolNodeConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedLabels, err := expandEdgecontainerNodePoolNodeConfigLabels(original["labels"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["labels"] = transformedLabels
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerNodePoolNodeConfigLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
+	if v == nil {
+		return map[string]string{}, nil
+	}
+	m := make(map[string]string)
+	for k, val := range v.(map[string]interface{}) {
+		m[k] = val.(string)
+	}
+	return m, nil
+}
\ No newline at end of file
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_node_pool_generated_test.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_node_pool_generated_test.go
new file mode 100644
index 000000000..3db0c9fcb
--- /dev/null
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_node_pool_generated_test.go
@@ -0,0 +1,142 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+// ----------------------------------------------------------------------------
+//
+//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
+//
+// ----------------------------------------------------------------------------
+//
+//     This file is automatically generated by Magic Modules and manual
+//     changes will be clobbered when the file is regenerated.
+//
+//     Please read more about how to change this file in
+//     .github/CONTRIBUTING.md.
+//
+// ----------------------------------------------------------------------------
+
+package edgecontainer_test
+
+import (
+	"fmt"
+	"strings"
+	"testing"
+
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
+
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/acctest"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
+	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
+)
+
+func TestAccEdgecontainerNodePool_edgecontainerLocalControlPlaneNodePoolInternalExample(t *testing.T) {
+	acctest.SkipIfVcr(t)
+	t.Parallel()
+
+	context := map[string]interface{}{
+		"random_suffix": acctest.RandString(t, 10),
+	}
+
+	acctest.VcrTest(t, resource.TestCase{
+		PreCheck:                 func() { acctest.AccTestPreCheck(t) },
+		ProtoV5ProviderFactories: acctest.ProtoV5ProviderFactories(t),
+		CheckDestroy:             testAccCheckEdgecontainerNodePoolDestroyProducer(t),
+		Steps: []resource.TestStep{
+			{
+				Config: testAccEdgecontainerNodePool_edgecontainerLocalControlPlaneNodePoolInternalExample(context),
+			},
+			{
+				ResourceName:            "google_edgecontainer_node_pool.default",
+				ImportState:             true,
+				ImportStateVerify:       true,
+				ImportStateVerifyIgnore: []string{"name", "location", "cluster"},
+			},
+		},
+	})
+}
+
+func testAccEdgecontainerNodePool_edgecontainerLocalControlPlaneNodePoolInternalExample(context map[string]interface{}) string {
+	return acctest.Nprintf(`
+resource "google_edgecontainer_cluster" "cluster" {
+  name = "tf-lcp-cluster"
+  location = "us-central1"
+
+  authorization {
+    admin_users {
+      username = "admin@hashicorptest.com"
+    }
+  }
+
+  networking {
+    cluster_ipv4_cidr_blocks = ["10.96.0.0/17"]
+    services_ipv4_cidr_blocks = ["10.0.0.0/21"]
+  }
+
+  fleet {
+    project = "projects/${data.google_project.project.number}"
+  }
+
+  external_load_balancer_ipv4_address_pools = ["10.100.68.100-10.100.68.102"]
+
+  control_plane {
+    local {
+      node_location = "us-central1-edge-den29"
+      node_count = 1
+      machine_filter = "den29-06"
+      shared_deployment_policy = "ALLOWED"
+    }
+  }
+}
+
+resource "google_edgecontainer_node_pool" "default" {
+  name = "nodepool-1"
+  cluster = google_edgecontainer_cluster.cluster.name
+  location = "us-central1"
+  node_location = "us-central1-edge-den29"
+  machine_filter = "NOT name:den29-01"
+  node_count = 1
+}
+
+data "google_project" "project" {}
+`, context)
+}
+
+func testAccCheckEdgecontainerNodePoolDestroyProducer(t *testing.T) func(s *terraform.State) error {
+	return func(s *terraform.State) error {
+		for name, rs := range s.RootModule().Resources {
+			if rs.Type != "google_edgecontainer_node_pool" {
+				continue
+			}
+			if strings.HasPrefix(name, "data.") {
+				continue
+			}
+
+			config := acctest.GoogleProviderConfig(t)
+
+			url, err := tpgresource.ReplaceVarsForTest(config, rs, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/nodePools/{{name}}")
+			if err != nil {
+				return err
+			}
+
+			billingProject := ""
+
+			if config.BillingProject != "" {
+				billingProject = config.BillingProject
+			}
+
+			_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+				Config:    config,
+				Method:    "GET",
+				Project:   billingProject,
+				RawURL:    url,
+				UserAgent: config.UserAgent,
+			})
+			if err == nil {
+				return fmt.Errorf("EdgecontainerNodePool still exists at %s", url)
+			}
+		}
+
+		return nil
+	}
+}
\ No newline at end of file
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_node_pool_sweeper.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_node_pool_sweeper.go
new file mode 100644
index 000000000..5d70da1fe
--- /dev/null
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_node_pool_sweeper.go
@@ -0,0 +1,139 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+// ----------------------------------------------------------------------------
+//
+//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
+//
+// ----------------------------------------------------------------------------
+//
+//     This file is automatically generated by Magic Modules and manual
+//     changes will be clobbered when the file is regenerated.
+//
+//     Please read more about how to change this file in
+//     .github/CONTRIBUTING.md.
+//
+// ----------------------------------------------------------------------------
+
+package edgecontainer
+
+import (
+	"context"
+	"log"
+	"strings"
+	"testing"
+
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/envvar"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/sweeper"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
+	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
+)
+
+func init() {
+	sweeper.AddTestSweepers("EdgecontainerNodePool", testSweepEdgecontainerNodePool)
+}
+
+// At the time of writing, the CI only passes us-central1 as the region
+func testSweepEdgecontainerNodePool(region string) error {
+	resourceName := "EdgecontainerNodePool"
+	log.Printf("[INFO][SWEEPER_LOG] Starting sweeper for %s", resourceName)
+
+	config, err := sweeper.SharedConfigForRegion(region)
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] error getting shared config for region: %s", err)
+		return err
+	}
+
+	err = config.LoadAndValidate(context.Background())
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] error loading: %s", err)
+		return err
+	}
+
+	t := &testing.T{}
+	billingId := envvar.GetTestBillingAccountFromEnv(t)
+
+	// Setup variables to replace in list template
+	d := &tpgresource.ResourceDataMock{
+		FieldsInSchema: map[string]interface{}{
+			"project":         config.Project,
+			"region":          region,
+			"location":        region,
+			"zone":            "-",
+			"billing_account": billingId,
+		},
+	}
+
+	listTemplate := strings.Split("https://edgecontainer.googleapis.com/v1/projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/nodePools", "?")[0]
+	listUrl, err := tpgresource.ReplaceVars(d, config, listTemplate)
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] error preparing sweeper list url: %s", err)
+		return nil
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "GET",
+		Project:   config.Project,
+		RawURL:    listUrl,
+		UserAgent: config.UserAgent,
+	})
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] Error in response from request %s: %s", listUrl, err)
+		return nil
+	}
+
+	resourceList, ok := res["nodePools"]
+	if !ok {
+		log.Printf("[INFO][SWEEPER_LOG] Nothing found in response.")
+		return nil
+	}
+
+	rl := resourceList.([]interface{})
+
+	log.Printf("[INFO][SWEEPER_LOG] Found %d items in %s list response.", len(rl), resourceName)
+	// Keep count of items that aren't sweepable for logging.
+	nonPrefixCount := 0
+	for _, ri := range rl {
+		obj := ri.(map[string]interface{})
+		if obj["name"] == nil {
+			log.Printf("[INFO][SWEEPER_LOG] %s resource name was nil", resourceName)
+			return nil
+		}
+
+		name := tpgresource.GetResourceNameFromSelfLink(obj["name"].(string))
+		// Skip resources that shouldn't be sweeped
+		if !sweeper.IsSweepableTestResource(name) {
+			nonPrefixCount++
+			continue
+		}
+
+		deleteTemplate := "https://edgecontainer.googleapis.com/v1/projects/{{project}}/locations/{{location}}/clusters/{{cluster}}/nodePools/{{name}}"
+		deleteUrl, err := tpgresource.ReplaceVars(d, config, deleteTemplate)
+		if err != nil {
+			log.Printf("[INFO][SWEEPER_LOG] error preparing delete url: %s", err)
+			return nil
+		}
+		deleteUrl = deleteUrl + name
+
+		// Don't wait on operations as we may have a lot to delete
+		_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+			Config:    config,
+			Method:    "DELETE",
+			Project:   config.Project,
+			RawURL:    deleteUrl,
+			UserAgent: config.UserAgent,
+		})
+		if err != nil {
+			log.Printf("[INFO][SWEEPER_LOG] Error deleting for url %s : %s", deleteUrl, err)
+		} else {
+			log.Printf("[INFO][SWEEPER_LOG] Sent delete request for %s resource: %s", resourceName, name)
+		}
+	}
+
+	if nonPrefixCount > 0 {
+		log.Printf("[INFO][SWEEPER_LOG] %d items were non-sweepable and skipped.", nonPrefixCount)
+	}
+
+	return nil
+}
\ No newline at end of file
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_vpn_connection.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_vpn_connection.go
new file mode 100644
index 000000000..73320226e
--- /dev/null
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_vpn_connection.go
@@ -0,0 +1,697 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+// ----------------------------------------------------------------------------
+//
+//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
+//
+// ----------------------------------------------------------------------------
+//
+//     This file is automatically generated by Magic Modules and manual
+//     changes will be clobbered when the file is regenerated.
+//
+//     Please read more about how to change this file in
+//     .github/CONTRIBUTING.md.
+//
+// ----------------------------------------------------------------------------
+
+package edgecontainer
+
+import (
+	"fmt"
+	"log"
+	"reflect"
+	"time"
+
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
+
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
+	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
+)
+
+func ResourceEdgecontainerVpnConnection() *schema.Resource {
+	return &schema.Resource{
+		Create: resourceEdgecontainerVpnConnectionCreate,
+		Read:   resourceEdgecontainerVpnConnectionRead,
+		Update: resourceEdgecontainerVpnConnectionUpdate,
+		Delete: resourceEdgecontainerVpnConnectionDelete,
+
+		Importer: &schema.ResourceImporter{
+			State: resourceEdgecontainerVpnConnectionImport,
+		},
+
+		Timeouts: &schema.ResourceTimeout{
+			Create: schema.DefaultTimeout(30 * time.Minute),
+			Update: schema.DefaultTimeout(30 * time.Minute),
+			Delete: schema.DefaultTimeout(30 * time.Minute),
+		},
+
+		Schema: map[string]*schema.Schema{
+			"cluster": {
+				Type:        schema.TypeString,
+				Required:    true,
+				ForceNew:    true,
+				Description: `The canonical Cluster name to connect to. It is in the form of projects/{project}/locations/{location}/clusters/{cluster}.`,
+			},
+			"location": {
+				Type:        schema.TypeString,
+				Required:    true,
+				ForceNew:    true,
+				Description: `Google Cloud Platform location.`,
+			},
+			"name": {
+				Type:        schema.TypeString,
+				Required:    true,
+				ForceNew:    true,
+				Description: `The resource name of VPN connection`,
+			},
+			"enable_high_availability": {
+				Type:        schema.TypeBool,
+				Computed:    true,
+				Optional:    true,
+				ForceNew:    true,
+				Description: `Whether this VPN connection has HA enabled on cluster side. If enabled, when creating VPN connection we will attempt to use 2 ANG floating IPs.`,
+			},
+			"labels": {
+				Type:        schema.TypeMap,
+				Computed:    true,
+				Optional:    true,
+				ForceNew:    true,
+				Description: `Labels associated with this resource.`,
+				Elem:        &schema.Schema{Type: schema.TypeString},
+			},
+			"nat_gateway_ip": {
+				Type:     schema.TypeString,
+				Optional: true,
+				ForceNew: true,
+				Description: `NAT gateway IP, or WAN IP address. If a customer has multiple NAT IPs, the customer needs to configure NAT such that only one external IP maps to the GMEC Anthos cluster.
+This is empty if NAT is not used.`,
+			},
+			"router": {
+				Type:        schema.TypeString,
+				Optional:    true,
+				Description: `The VPN connection Cloud Router name.`,
+			},
+			"vpc": {
+				Type:        schema.TypeString,
+				Optional:    true,
+				ForceNew:    true,
+				Description: `The network ID of VPC to connect to.`,
+			},
+			"vpc_project": {
+				Type:        schema.TypeList,
+				Optional:    true,
+				Description: `Project detail of the VPC network. Required if VPC is in a different project than the cluster project.`,
+				MaxItems:    1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"project_id": {
+							Type:        schema.TypeString,
+							Optional:    true,
+							ForceNew:    true,
+							Description: `The project of the VPC to connect to. If not specified, it is the same as the cluster project.`,
+						},
+					},
+				},
+			},
+			"create_time": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The time when the VPN connection was created.`,
+			},
+			"details": {
+				Type:        schema.TypeList,
+				Computed:    true,
+				Description: `A nested object resource`,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"cloud_router": {
+							Type:        schema.TypeList,
+							Computed:    true,
+							Description: `The Cloud Router info.`,
+							Elem: &schema.Resource{
+								Schema: map[string]*schema.Schema{
+									"name": {
+										Type:        schema.TypeString,
+										Computed:    true,
+										Description: `The associated Cloud Router name.`,
+									},
+								},
+							},
+						},
+						"cloud_vpns": {
+							Type:        schema.TypeList,
+							Computed:    true,
+							Description: `Each connection has multiple Cloud VPN gateways.`,
+							Elem: &schema.Resource{
+								Schema: map[string]*schema.Schema{
+									"gateway": {
+										Type:        schema.TypeString,
+										Computed:    true,
+										Description: `The created Cloud VPN gateway name.`,
+									},
+								},
+							},
+						},
+						"error": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `The error message. This is only populated when state=ERROR.`,
+						},
+						"state": {
+							Type:        schema.TypeString,
+							Computed:    true,
+							Description: `The current connection state.`,
+						},
+					},
+				},
+			},
+			"update_time": {
+				Type:        schema.TypeString,
+				Computed:    true,
+				Description: `The time when the VPN connection was last updated.`,
+			},
+			"project": {
+				Type:     schema.TypeString,
+				Optional: true,
+				Computed: true,
+				ForceNew: true,
+			},
+		},
+		UseJSONNumber: true,
+	}
+}
+
+func resourceEdgecontainerVpnConnectionCreate(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	obj := make(map[string]interface{})
+	labelsProp, err := expandEdgecontainerVpnConnectionLabels(d.Get("labels"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
+		obj["labels"] = labelsProp
+	}
+	natGatewayIpProp, err := expandEdgecontainerVpnConnectionNatGatewayIp(d.Get("nat_gateway_ip"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("nat_gateway_ip"); !tpgresource.IsEmptyValue(reflect.ValueOf(natGatewayIpProp)) && (ok || !reflect.DeepEqual(v, natGatewayIpProp)) {
+		obj["natGatewayIp"] = natGatewayIpProp
+	}
+	clusterProp, err := expandEdgecontainerVpnConnectionCluster(d.Get("cluster"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(clusterProp)) && (ok || !reflect.DeepEqual(v, clusterProp)) {
+		obj["cluster"] = clusterProp
+	}
+	vpcProp, err := expandEdgecontainerVpnConnectionVpc(d.Get("vpc"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("vpc"); !tpgresource.IsEmptyValue(reflect.ValueOf(vpcProp)) && (ok || !reflect.DeepEqual(v, vpcProp)) {
+		obj["vpc"] = vpcProp
+	}
+	vpcProjectProp, err := expandEdgecontainerVpnConnectionVpcProject(d.Get("vpc_project"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("vpc_project"); !tpgresource.IsEmptyValue(reflect.ValueOf(vpcProjectProp)) && (ok || !reflect.DeepEqual(v, vpcProjectProp)) {
+		obj["vpcProject"] = vpcProjectProp
+	}
+	enableHighAvailabilityProp, err := expandEdgecontainerVpnConnectionEnableHighAvailability(d.Get("enable_high_availability"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("enable_high_availability"); !tpgresource.IsEmptyValue(reflect.ValueOf(enableHighAvailabilityProp)) && (ok || !reflect.DeepEqual(v, enableHighAvailabilityProp)) {
+		obj["enableHighAvailability"] = enableHighAvailabilityProp
+	}
+	routerProp, err := expandEdgecontainerVpnConnectionRouter(d.Get("router"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("router"); !tpgresource.IsEmptyValue(reflect.ValueOf(routerProp)) && (ok || !reflect.DeepEqual(v, routerProp)) {
+		obj["router"] = routerProp
+	}
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/vpnConnections?vpnConnectionId={{name}}")
+	if err != nil {
+		return err
+	}
+
+	log.Printf("[DEBUG] Creating new VpnConnection: %#v", obj)
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for VpnConnection: %s", err)
+	}
+	billingProject = project
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "POST",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+		Body:      obj,
+		Timeout:   d.Timeout(schema.TimeoutCreate),
+	})
+	if err != nil {
+		return fmt.Errorf("Error creating VpnConnection: %s", err)
+	}
+
+	// Store the ID now
+	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vpnConnections/{{name}}")
+	if err != nil {
+		return fmt.Errorf("Error constructing id: %s", err)
+	}
+	d.SetId(id)
+
+	err = EdgecontainerOperationWaitTime(
+		config, res, project, "Creating VpnConnection", userAgent,
+		d.Timeout(schema.TimeoutCreate))
+
+	if err != nil {
+		// The resource didn't actually create
+		d.SetId("")
+		return fmt.Errorf("Error waiting to create VpnConnection: %s", err)
+	}
+
+	log.Printf("[DEBUG] Finished creating VpnConnection %q: %#v", d.Id(), res)
+
+	return resourceEdgecontainerVpnConnectionRead(d, meta)
+}
+
+func resourceEdgecontainerVpnConnectionRead(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/vpnConnections/{{name}}")
+	if err != nil {
+		return err
+	}
+
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for VpnConnection: %s", err)
+	}
+	billingProject = project
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "GET",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+	})
+	if err != nil {
+		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("EdgecontainerVpnConnection %q", d.Id()))
+	}
+
+	if err := d.Set("project", project); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+
+	if err := d.Set("create_time", flattenEdgecontainerVpnConnectionCreateTime(res["createTime"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+	if err := d.Set("update_time", flattenEdgecontainerVpnConnectionUpdateTime(res["updateTime"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+	if err := d.Set("labels", flattenEdgecontainerVpnConnectionLabels(res["labels"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+	if err := d.Set("nat_gateway_ip", flattenEdgecontainerVpnConnectionNatGatewayIp(res["natGatewayIp"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+	if err := d.Set("cluster", flattenEdgecontainerVpnConnectionCluster(res["cluster"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+	if err := d.Set("vpc", flattenEdgecontainerVpnConnectionVpc(res["vpc"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+	if err := d.Set("vpc_project", flattenEdgecontainerVpnConnectionVpcProject(res["vpcProject"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+	if err := d.Set("enable_high_availability", flattenEdgecontainerVpnConnectionEnableHighAvailability(res["enableHighAvailability"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+	if err := d.Set("router", flattenEdgecontainerVpnConnectionRouter(res["router"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+	if err := d.Set("details", flattenEdgecontainerVpnConnectionDetails(res["details"], d, config)); err != nil {
+		return fmt.Errorf("Error reading VpnConnection: %s", err)
+	}
+
+	return nil
+}
+
+func resourceEdgecontainerVpnConnectionUpdate(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for VpnConnection: %s", err)
+	}
+	billingProject = project
+
+	obj := make(map[string]interface{})
+	labelsProp, err := expandEdgecontainerVpnConnectionLabels(d.Get("labels"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
+		obj["labels"] = labelsProp
+	}
+	natGatewayIpProp, err := expandEdgecontainerVpnConnectionNatGatewayIp(d.Get("nat_gateway_ip"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("nat_gateway_ip"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, natGatewayIpProp)) {
+		obj["natGatewayIp"] = natGatewayIpProp
+	}
+	clusterProp, err := expandEdgecontainerVpnConnectionCluster(d.Get("cluster"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("cluster"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, clusterProp)) {
+		obj["cluster"] = clusterProp
+	}
+	vpcProp, err := expandEdgecontainerVpnConnectionVpc(d.Get("vpc"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("vpc"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, vpcProp)) {
+		obj["vpc"] = vpcProp
+	}
+	vpcProjectProp, err := expandEdgecontainerVpnConnectionVpcProject(d.Get("vpc_project"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("vpc_project"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, vpcProjectProp)) {
+		obj["vpcProject"] = vpcProjectProp
+	}
+	enableHighAvailabilityProp, err := expandEdgecontainerVpnConnectionEnableHighAvailability(d.Get("enable_high_availability"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("enable_high_availability"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, enableHighAvailabilityProp)) {
+		obj["enableHighAvailability"] = enableHighAvailabilityProp
+	}
+	routerProp, err := expandEdgecontainerVpnConnectionRouter(d.Get("router"), d, config)
+	if err != nil {
+		return err
+	} else if v, ok := d.GetOkExists("router"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, routerProp)) {
+		obj["router"] = routerProp
+	}
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/vpnConnections/{{name}}")
+	if err != nil {
+		return err
+	}
+
+	log.Printf("[DEBUG] Updating VpnConnection %q: %#v", d.Id(), obj)
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "PUT",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+		Body:      obj,
+		Timeout:   d.Timeout(schema.TimeoutUpdate),
+	})
+
+	if err != nil {
+		return fmt.Errorf("Error updating VpnConnection %q: %s", d.Id(), err)
+	} else {
+		log.Printf("[DEBUG] Finished updating VpnConnection %q: %#v", d.Id(), res)
+	}
+
+	err = EdgecontainerOperationWaitTime(
+		config, res, project, "Updating VpnConnection", userAgent,
+		d.Timeout(schema.TimeoutUpdate))
+
+	if err != nil {
+		return err
+	}
+
+	return resourceEdgecontainerVpnConnectionRead(d, meta)
+}
+
+func resourceEdgecontainerVpnConnectionDelete(d *schema.ResourceData, meta interface{}) error {
+	config := meta.(*transport_tpg.Config)
+	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
+	if err != nil {
+		return err
+	}
+
+	billingProject := ""
+
+	project, err := tpgresource.GetProject(d, config)
+	if err != nil {
+		return fmt.Errorf("Error fetching project for VpnConnection: %s", err)
+	}
+	billingProject = project
+
+	url, err := tpgresource.ReplaceVars(d, config, "{{EdgecontainerBasePath}}projects/{{project}}/locations/{{location}}/vpnConnections/{{name}}")
+	if err != nil {
+		return err
+	}
+
+	var obj map[string]interface{}
+	log.Printf("[DEBUG] Deleting VpnConnection %q", d.Id())
+
+	// err == nil indicates that the billing_project value was found
+	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
+		billingProject = bp
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "DELETE",
+		Project:   billingProject,
+		RawURL:    url,
+		UserAgent: userAgent,
+		Body:      obj,
+		Timeout:   d.Timeout(schema.TimeoutDelete),
+	})
+	if err != nil {
+		return transport_tpg.HandleNotFoundError(err, d, "VpnConnection")
+	}
+
+	err = EdgecontainerOperationWaitTime(
+		config, res, project, "Deleting VpnConnection", userAgent,
+		d.Timeout(schema.TimeoutDelete))
+
+	if err != nil {
+		return err
+	}
+
+	log.Printf("[DEBUG] Finished deleting VpnConnection %q: %#v", d.Id(), res)
+	return nil
+}
+
+func resourceEdgecontainerVpnConnectionImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
+	config := meta.(*transport_tpg.Config)
+	if err := tpgresource.ParseImportId([]string{
+		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/vpnConnections$",
+		"^(?P<project>[^/]+)/(?P<location>[^/]+)$",
+		"^(?P<location>[^/]+)$",
+	}, d, config); err != nil {
+		return nil, err
+	}
+
+	// Replace import id for the resource id
+	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/vpnConnections/{{name}}")
+	if err != nil {
+		return nil, fmt.Errorf("Error constructing id: %s", err)
+	}
+	d.SetId(id)
+
+	return []*schema.ResourceData{d}, nil
+}
+
+func flattenEdgecontainerVpnConnectionCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionNatGatewayIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionCluster(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionVpc(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionVpcProject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["project_id"] =
+		flattenEdgecontainerVpnConnectionVpcProjectProjectId(original["projectId"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerVpnConnectionVpcProjectProjectId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionEnableHighAvailability(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionRouter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionDetails(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["state"] =
+		flattenEdgecontainerVpnConnectionDetailsState(original["state"], d, config)
+	transformed["error"] =
+		flattenEdgecontainerVpnConnectionDetailsError(original["error"], d, config)
+	transformed["cloud_router"] =
+		flattenEdgecontainerVpnConnectionDetailsCloudRouter(original["cloudRouter"], d, config)
+	transformed["cloud_vpns"] =
+		flattenEdgecontainerVpnConnectionDetailsCloudVpns(original["cloudVpns"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerVpnConnectionDetailsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionDetailsError(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionDetailsCloudRouter(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["name"] =
+		flattenEdgecontainerVpnConnectionDetailsCloudRouterName(original["name"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerVpnConnectionDetailsCloudRouterName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func flattenEdgecontainerVpnConnectionDetailsCloudVpns(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	if v == nil {
+		return nil
+	}
+	original := v.(map[string]interface{})
+	if len(original) == 0 {
+		return nil
+	}
+	transformed := make(map[string]interface{})
+	transformed["gateway"] =
+		flattenEdgecontainerVpnConnectionDetailsCloudVpnsGateway(original["gateway"], d, config)
+	return []interface{}{transformed}
+}
+func flattenEdgecontainerVpnConnectionDetailsCloudVpnsGateway(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
+	return v
+}
+
+func expandEdgecontainerVpnConnectionLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
+	if v == nil {
+		return map[string]string{}, nil
+	}
+	m := make(map[string]string)
+	for k, val := range v.(map[string]interface{}) {
+		m[k] = val.(string)
+	}
+	return m, nil
+}
+
+func expandEdgecontainerVpnConnectionNatGatewayIp(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerVpnConnectionCluster(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerVpnConnectionVpc(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerVpnConnectionVpcProject(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	l := v.([]interface{})
+	if len(l) == 0 || l[0] == nil {
+		return nil, nil
+	}
+	raw := l[0]
+	original := raw.(map[string]interface{})
+	transformed := make(map[string]interface{})
+
+	transformedProjectId, err := expandEdgecontainerVpnConnectionVpcProjectProjectId(original["project_id"], d, config)
+	if err != nil {
+		return nil, err
+	} else if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
+		transformed["projectId"] = transformedProjectId
+	}
+
+	return transformed, nil
+}
+
+func expandEdgecontainerVpnConnectionVpcProjectProjectId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerVpnConnectionEnableHighAvailability(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
+
+func expandEdgecontainerVpnConnectionRouter(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
+	return v, nil
+}
\ No newline at end of file
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_vpn_connection_sweeper.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_vpn_connection_sweeper.go
new file mode 100644
index 000000000..7212f938f
--- /dev/null
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer/resource_edgecontainer_vpn_connection_sweeper.go
@@ -0,0 +1,139 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+// ----------------------------------------------------------------------------
+//
+//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
+//
+// ----------------------------------------------------------------------------
+//
+//     This file is automatically generated by Magic Modules and manual
+//     changes will be clobbered when the file is regenerated.
+//
+//     Please read more about how to change this file in
+//     .github/CONTRIBUTING.md.
+//
+// ----------------------------------------------------------------------------
+
+package edgecontainer
+
+import (
+	"context"
+	"log"
+	"strings"
+	"testing"
+
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/envvar"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/sweeper"
+	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
+	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
+)
+
+func init() {
+	sweeper.AddTestSweepers("EdgecontainerVpnConnection", testSweepEdgecontainerVpnConnection)
+}
+
+// At the time of writing, the CI only passes us-central1 as the region
+func testSweepEdgecontainerVpnConnection(region string) error {
+	resourceName := "EdgecontainerVpnConnection"
+	log.Printf("[INFO][SWEEPER_LOG] Starting sweeper for %s", resourceName)
+
+	config, err := sweeper.SharedConfigForRegion(region)
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] error getting shared config for region: %s", err)
+		return err
+	}
+
+	err = config.LoadAndValidate(context.Background())
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] error loading: %s", err)
+		return err
+	}
+
+	t := &testing.T{}
+	billingId := envvar.GetTestBillingAccountFromEnv(t)
+
+	// Setup variables to replace in list template
+	d := &tpgresource.ResourceDataMock{
+		FieldsInSchema: map[string]interface{}{
+			"project":         config.Project,
+			"region":          region,
+			"location":        region,
+			"zone":            "-",
+			"billing_account": billingId,
+		},
+	}
+
+	listTemplate := strings.Split("https://edgecontainer.googleapis.com/v1/projects/{{project}}/locations/{{location}}/vpnConnections", "?")[0]
+	listUrl, err := tpgresource.ReplaceVars(d, config, listTemplate)
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] error preparing sweeper list url: %s", err)
+		return nil
+	}
+
+	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+		Config:    config,
+		Method:    "GET",
+		Project:   config.Project,
+		RawURL:    listUrl,
+		UserAgent: config.UserAgent,
+	})
+	if err != nil {
+		log.Printf("[INFO][SWEEPER_LOG] Error in response from request %s: %s", listUrl, err)
+		return nil
+	}
+
+	resourceList, ok := res["vpnConnections"]
+	if !ok {
+		log.Printf("[INFO][SWEEPER_LOG] Nothing found in response.")
+		return nil
+	}
+
+	rl := resourceList.([]interface{})
+
+	log.Printf("[INFO][SWEEPER_LOG] Found %d items in %s list response.", len(rl), resourceName)
+	// Keep count of items that aren't sweepable for logging.
+	nonPrefixCount := 0
+	for _, ri := range rl {
+		obj := ri.(map[string]interface{})
+		if obj["name"] == nil {
+			log.Printf("[INFO][SWEEPER_LOG] %s resource name was nil", resourceName)
+			return nil
+		}
+
+		name := tpgresource.GetResourceNameFromSelfLink(obj["name"].(string))
+		// Skip resources that shouldn't be sweeped
+		if !sweeper.IsSweepableTestResource(name) {
+			nonPrefixCount++
+			continue
+		}
+
+		deleteTemplate := "https://edgecontainer.googleapis.com/v1/projects/{{project}}/locations/{{location}}/vpnConnections/{{name}}"
+		deleteUrl, err := tpgresource.ReplaceVars(d, config, deleteTemplate)
+		if err != nil {
+			log.Printf("[INFO][SWEEPER_LOG] error preparing delete url: %s", err)
+			return nil
+		}
+		deleteUrl = deleteUrl + name
+
+		// Don't wait on operations as we may have a lot to delete
+		_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
+			Config:    config,
+			Method:    "DELETE",
+			Project:   config.Project,
+			RawURL:    deleteUrl,
+			UserAgent: config.UserAgent,
+		})
+		if err != nil {
+			log.Printf("[INFO][SWEEPER_LOG] Error deleting for url %s : %s", deleteUrl, err)
+		} else {
+			log.Printf("[INFO][SWEEPER_LOG] Sent delete request for %s resource: %s", resourceName, name)
+		}
+	}
+
+	if nonPrefixCount > 0 {
+		log.Printf("[INFO][SWEEPER_LOG] %d items were non-sweepable and skipped.", nonPrefixCount)
+	}
+
+	return nil
+}
\ No newline at end of file
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/sweeper/gcp_sweeper_test.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/sweeper/gcp_sweeper_test.go
index 7fd1b9ffc..21b948bd1 100644
--- a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/sweeper/gcp_sweeper_test.go
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/sweeper/gcp_sweeper_test.go
@@ -62,6 +62,7 @@ import (
 	_ "github.com/hashicorp/terraform-provider-google-beta/google-beta/services/documentai"
 	_ "github.com/hashicorp/terraform-provider-google-beta/google-beta/services/documentaiwarehouse"
 	_ "github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgenetwork"
+	_ "github.com/hashicorp/terraform-provider-google-beta/google-beta/services/edgecontainer"
 	_ "github.com/hashicorp/terraform-provider-google-beta/google-beta/services/essentialcontacts"
 	_ "github.com/hashicorp/terraform-provider-google-beta/google-beta/services/filestore"
 	_ "github.com/hashicorp/terraform-provider-google-beta/google-beta/services/firebase"
diff --git a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/transport/config.go b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/transport/config.go
index 5e8d35e37..99d877b0d 100644
--- a/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/transport/config.go
+++ b/third_party/github.com/hashicorp/terraform-provider-google-beta/google-beta/transport/config.go
@@ -238,6 +238,7 @@ type Config struct {
 	DocumentAIBasePath               string
 	DocumentAIWarehouseBasePath      string
 	EdgenetworkBasePath              string
+	EdgecontainerBasePath            string
 	EssentialContactsBasePath        string
 	FilestoreBasePath                string
 	FirebaseBasePath                 string
@@ -374,6 +375,7 @@ const DNSBasePathKey = "DNS"
 const DocumentAIBasePathKey = "DocumentAI"
 const DocumentAIWarehouseBasePathKey = "DocumentAIWarehouse"
 const EdgenetworkBasePathKey = "Edgenetwork"
+const EdgecontainerBasePathKey = "Edgecontainer"
 const EssentialContactsBasePathKey = "EssentialContacts"
 const FilestoreBasePathKey = "Filestore"
 const FirebaseBasePathKey = "Firebase"
@@ -504,6 +506,7 @@ var DefaultBasePaths = map[string]string{
 	DocumentAIBasePathKey:               "https://{{location}}-documentai.googleapis.com/v1/",
 	DocumentAIWarehouseBasePathKey:      "https://contentwarehouse.googleapis.com/v1/",
 	EdgenetworkBasePathKey:              "https://edgenetwork.googleapis.com/v1/",
+	EdgecontainerBasePathKey:            "https://edgecontainer.googleapis.com/v1/",
 	EssentialContactsBasePathKey:        "https://essentialcontacts.googleapis.com/v1/",
 	FilestoreBasePathKey:                "https://file.googleapis.com/v1beta1/",
 	FirebaseBasePathKey:                 "https://firebase.googleapis.com/v1beta1/",
@@ -925,6 +928,11 @@ func HandleSDKDefaults(d *schema.ResourceData) error {
 			"GOOGLE_EDGENETWORK_CUSTOM_ENDPOINT",
 		}, DefaultBasePaths[EdgenetworkBasePathKey]))
 	}
+	if d.Get("edgecontainer_custom_endpoint") == "" {
+		d.Set("edgecontainer_custom_endpoint", MultiEnvDefault([]string{
+			"GOOGLE_EDGECONTAINER_CUSTOM_ENDPOINT",
+		}, DefaultBasePaths[EdgecontainerBasePathKey]))
+	}
 	if d.Get("essential_contacts_custom_endpoint") == "" {
 		d.Set("essential_contacts_custom_endpoint", MultiEnvDefault([]string{
 			"GOOGLE_ESSENTIAL_CONTACTS_CUSTOM_ENDPOINT",
@@ -2147,6 +2155,7 @@ func ConfigureBasePaths(c *Config) {
 	c.DocumentAIBasePath = DefaultBasePaths[DocumentAIBasePathKey]
 	c.DocumentAIWarehouseBasePath = DefaultBasePaths[DocumentAIWarehouseBasePathKey]
 	c.EdgenetworkBasePath = DefaultBasePaths[EdgenetworkBasePathKey]
+	c.EdgecontainerBasePath = DefaultBasePaths[EdgecontainerBasePathKey]
 	c.EssentialContactsBasePath = DefaultBasePaths[EssentialContactsBasePathKey]
 	c.FilestoreBasePath = DefaultBasePaths[FilestoreBasePathKey]
 	c.FirebaseBasePath = DefaultBasePaths[FirebaseBasePathKey]
