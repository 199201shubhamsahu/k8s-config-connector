// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Config Connector and manual
//     changes will be clobbered when the file is regenerated.
//
// ----------------------------------------------------------------------------

// *** DISCLAIMER ***
// Config Connector's go-client for CRDs is currently in ALPHA, which means
// that future versions of the go-client may include breaking changes.
// Please try it out and give us feedback!

package v1beta1

import (
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/apis/k8s/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type ForwardingruleFilterLabels struct {
	/* Immutable. Name of the metadata label. The length must be between
	1 and 1024 characters, inclusive. */
	Name string `json:"name"`

	/* Immutable. The value that the label must match. The value has a maximum
	length of 1024 characters. */
	Value string `json:"value"`
}

type ForwardingruleIpAddress struct {
	/*  */
	// +optional
	AddressRef *v1alpha1.ResourceRef `json:"addressRef,omitempty"`

	/*  */
	// +optional
	Ip *string `json:"ip,omitempty"`
}

type ForwardingruleMetadataFilters struct {
	/* Immutable. The list of label value pairs that must match labels in the
	provided metadata based on filterMatchCriteria

	This list must not be empty and can have at the most 64 entries. */
	FilterLabels []ForwardingruleFilterLabels `json:"filterLabels"`

	/* Immutable. Specifies how individual filterLabel matches within the list of
	filterLabels contribute towards the overall metadataFilter match.

	MATCH_ANY - At least one of the filterLabels must have a matching
	label in the provided metadata.
	MATCH_ALL - All filterLabels must have matching labels in the
	provided metadata. Possible values: ["MATCH_ANY", "MATCH_ALL"] */
	FilterMatchCriteria string `json:"filterMatchCriteria"`
}

type ForwardingruleTarget struct {
	/*  */
	// +optional
	TargetGRPCProxyRef *v1alpha1.ResourceRef `json:"targetGRPCProxyRef,omitempty"`

	/*  */
	// +optional
	TargetHTTPProxyRef *v1alpha1.ResourceRef `json:"targetHTTPProxyRef,omitempty"`

	/*  */
	// +optional
	TargetHTTPSProxyRef *v1alpha1.ResourceRef `json:"targetHTTPSProxyRef,omitempty"`

	/*  */
	// +optional
	TargetSSLProxyRef *v1alpha1.ResourceRef `json:"targetSSLProxyRef,omitempty"`

	/*  */
	// +optional
	TargetTCPProxyRef *v1alpha1.ResourceRef `json:"targetTCPProxyRef,omitempty"`

	/*  */
	// +optional
	TargetVPNGatewayRef *v1alpha1.ResourceRef `json:"targetVPNGatewayRef,omitempty"`
}

type ComputeForwardingRuleSpec struct {
	/* Immutable. This field can be used with internal load balancer or network load balancer
	when the forwarding rule references a backend service, or with the target
	field when it references a TargetInstance. Set this to true to
	allow packets addressed to any ports to be forwarded to the backends configured
	with this forwarding rule. This can be used when the protocol is TCP/UDP, and it
	must be set to true when the protocol is set to L3_DEFAULT.
	Cannot be set if port or portRange are set. */
	// +optional
	AllPorts *bool `json:"allPorts,omitempty"`

	/* If true, clients can access ILB from all regions.
	Otherwise only allows from the local region the ILB is located at. */
	// +optional
	AllowGlobalAccess *bool `json:"allowGlobalAccess,omitempty"`

	/* A ComputeBackendService to receive the matched traffic. This is
	used only for internal load balancing. */
	// +optional
	BackendServiceRef *v1alpha1.ResourceRef `json:"backendServiceRef,omitempty"`

	/* Immutable. An optional description of this resource. Provide this property when
	you create the resource. */
	// +optional
	Description *string `json:"description,omitempty"`

	/* The IP address that this forwarding rule is serving on behalf of.

	Addresses are restricted based on the forwarding rule's load
	balancing scheme (EXTERNAL or INTERNAL) and scope (global or
	regional).

	When the load balancing scheme is EXTERNAL, for global forwarding
	rules, the address must be a global IP, and for regional forwarding
	rules, the address must live in the same region as the forwarding
	rule. If this field is empty, an ephemeral IPv4 address from the
	same scope (global or regional) will be assigned. A regional
	forwarding rule supports IPv4 only. A global forwarding rule
	supports either IPv4 or IPv6.

	When the load balancing scheme is INTERNAL, this can only be an RFC
	1918 IP address belonging to the network/subnet configured for the
	forwarding rule. By default, if this field is empty, an ephemeral
	internal IP address will be automatically allocated from the IP
	range of the subnet or network configured for this forwarding rule. */
	// +optional
	IpAddress *ForwardingruleIpAddress `json:"ipAddress,omitempty"`

	/* Immutable. The IP protocol to which this rule applies.

	When the load balancing scheme is INTERNAL, only TCP and UDP are
	valid. Possible values: ["TCP", "UDP", "ESP", "AH", "SCTP", "ICMP", "L3_DEFAULT"] */
	// +optional
	IpProtocol *string `json:"ipProtocol,omitempty"`

	/* Immutable. The IP Version that will be used by this global forwarding rule. Possible values: ["IPV4", "IPV6"] */
	// +optional
	IpVersion *string `json:"ipVersion,omitempty"`

	/* Immutable. Indicates whether or not this load balancer can be used
	as a collector for packet mirroring. To prevent mirroring loops,
	instances behind this load balancer will not have their traffic
	mirrored even if a PacketMirroring rule applies to them. This
	can only be set to true for load balancers that have their
	loadBalancingScheme set to INTERNAL. */
	// +optional
	IsMirroringCollector *bool `json:"isMirroringCollector,omitempty"`

	/* Immutable. This signifies what the ForwardingRule will be used for and can be
	EXTERNAL, INTERNAL, or INTERNAL_MANAGED. EXTERNAL is used for Classic
	Cloud VPN gateways, protocol forwarding to VMs from an external IP address,
	and HTTP(S), SSL Proxy, TCP Proxy, and Network TCP/UDP load balancers.
	INTERNAL is used for protocol forwarding to VMs from an internal IP address,
	and internal TCP/UDP load balancers.
	INTERNAL_MANAGED is used for internal HTTP(S) load balancers. Default value: "EXTERNAL" Possible values: ["EXTERNAL", "INTERNAL", "INTERNAL_MANAGED"] */
	// +optional
	LoadBalancingScheme *string `json:"loadBalancingScheme,omitempty"`

	/* Location represents the geographical location of the ComputeForwardingRule. Specify a region name or "global" for global resources. Reference: GCP definition of regions/zones (https://cloud.google.com/compute/docs/regions-zones/) */
	Location string `json:"location"`

	/* Immutable. Opaque filter criteria used by Loadbalancer to restrict routing
	configuration to a limited set xDS compliant clients. In their xDS
	requests to Loadbalancer, xDS clients present node metadata. If a
	match takes place, the relevant routing configuration is made available
	to those proxies.

	For each metadataFilter in this list, if its filterMatchCriteria is set
	to MATCH_ANY, at least one of the filterLabels must match the
	corresponding label provided in the metadata. If its filterMatchCriteria
	is set to MATCH_ALL, then all of its filterLabels must match with
	corresponding labels in the provided metadata.

	metadataFilters specified here can be overridden by those specified in
	the UrlMap that this ForwardingRule references.

	metadataFilters only applies to Loadbalancers that have their
	loadBalancingScheme set to INTERNAL_SELF_MANAGED. */
	// +optional
	MetadataFilters []ForwardingruleMetadataFilters `json:"metadataFilters,omitempty"`

	/* This field is not used for external load balancing. For internal
	load balancing, this field identifies the network that the load
	balanced IP should belong to for this forwarding rule. If this
	field is not specified, the default network will be used. */
	// +optional
	NetworkRef *v1alpha1.ResourceRef `json:"networkRef,omitempty"`

	/* Immutable. The networking tier used for configuring this address. If this field is not
	specified, it is assumed to be PREMIUM. Possible values: ["PREMIUM", "STANDARD"] */
	// +optional
	NetworkTier *string `json:"networkTier,omitempty"`

	/* Immutable. This field is used along with the target field for TargetHttpProxy,
	TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
	TargetPool, TargetInstance.

	Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
	addressed to ports in the specified range will be forwarded to target.
	Forwarding rules with the same [IPAddress, IPProtocol] pair must have
	disjoint port ranges.

	Some types of forwarding target have constraints on the acceptable
	ports:

	* TargetHttpProxy: 80, 8080
	* TargetHttpsProxy: 443
	* TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	                  1883, 5222
	* TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
	                  1883, 5222
	* TargetVpnGateway: 500, 4500 */
	// +optional
	PortRange *string `json:"portRange,omitempty"`

	/* Immutable. This field is used along with internal load balancing and network
	load balancer when the forwarding rule references a backend service
	and when protocol is not L3_DEFAULT.

	A single port or a comma separated list of ports can be configured.
	Only packets addressed to these ports will be forwarded to the backends
	configured with this forwarding rule.

	You can only use one of ports and portRange, or allPorts.
	The three are mutually exclusive.

	You may specify a maximum of up to 5 ports, which can be non-contiguous. */
	// +optional
	Ports []string `json:"ports,omitempty"`

	/* Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default. */
	// +optional
	ResourceID *string `json:"resourceID,omitempty"`

	/* Immutable. An optional prefix to the service name for this Forwarding Rule.
	If specified, will be the first label of the fully qualified service
	name.

	The label must be 1-63 characters long, and comply with RFC1035.
	Specifically, the label must be 1-63 characters long and match the
	regular expression '[a-z]([-a-z0-9]*[a-z0-9])?' which means the first
	character must be a lowercase letter, and all following characters
	must be a dash, lowercase letter, or digit, except the last
	character, which cannot be a dash.

	This field is only used for INTERNAL load balancing. */
	// +optional
	ServiceLabel *string `json:"serviceLabel,omitempty"`

	/* The subnetwork that the load balanced IP should belong to for this
	forwarding rule. This field is only used for internal load
	balancing.

	If the network specified is in auto subnet mode, this field is
	optional. However, if the network is in custom subnet mode, a
	subnetwork must be specified. */
	// +optional
	SubnetworkRef *v1alpha1.ResourceRef `json:"subnetworkRef,omitempty"`

	/* The target resource to receive the matched traffic. The forwarded
	traffic must be of a type appropriate to the target object. For
	INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
	are valid. */
	// +optional
	Target *ForwardingruleTarget `json:"target,omitempty"`
}

type ComputeForwardingRuleStatus struct {
	/* Conditions represent the latest available observations of the
	   ComputeForwardingRule's current state. */
	Conditions []v1alpha1.Condition `json:"conditions,omitempty"`
	/* Creation timestamp in RFC3339 text format. */
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	/* The fingerprint used for optimistic locking of this resource.  Used
	internally during updates. */
	LabelFingerprint string `json:"labelFingerprint,omitempty"`
	/* ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource. */
	ObservedGeneration int `json:"observedGeneration,omitempty"`
	/*  */
	SelfLink string `json:"selfLink,omitempty"`
	/* The internal fully qualified service name for this Forwarding Rule.
	This field is only used for INTERNAL load balancing. */
	ServiceName string `json:"serviceName,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ComputeForwardingRule is the Schema for the compute API
// +k8s:openapi-gen=true
type ComputeForwardingRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ComputeForwardingRuleSpec   `json:"spec,omitempty"`
	Status ComputeForwardingRuleStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ComputeForwardingRuleList contains a list of ComputeForwardingRule
type ComputeForwardingRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ComputeForwardingRule `json:"items"`
}

func init() {
	SchemeBuilder.Register(&ComputeForwardingRule{}, &ComputeForwardingRuleList{})
}
